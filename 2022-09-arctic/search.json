[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Scalable and Computationally Reproducible Approaches to Arctic Research",
    "section": "",
    "text": "This 5-day in-person workshop will provide researchers with an introduction to advanced topics in computationally reproducible research in python and R, including software and techniques for working with very large datasets. This includes working in cloud computing environments, docker containers, and parallel processing using tools like parsl and dask. The workshop will also cover concrete methods for documenting and uploading data to the Arctic Data Center, advanced approaches to tracking data provenance, responsible research and data management practices including data sovereignty and the CARE principles, and ethical concerns with data-intensive modeling and analysis.\n\n\n\n\n\n\n\n\n\n\nPlease note that by participating in this activity you agree to abide by the NCEAS Code of Conduct.\n\n\n\n\nIn this course, we will be using Python (> 3.0) as our primary language, and VS Code as our IDE. Below are instructions on how to get VS Code set up to work for the course. If you are already a regular Python user, you may already have another IDE set up. We strongly encourage you to set up VS Code with us, because we will use your local VS Code instance to write and execute code on one of the NCEAS servers.\n\n\nFirst, download VS Code if you do not already have it installed.\nCheck to make sure you have Python installed if you aren’t sure you do. To do this, from the terminal run:\npython3 --version\nIf you get an error, it means you need to install Python. Here are instructions for getting installed, depending on your operating system. Note: There are many ways to install and manage your Python installations, and advantages and drawbacks to each. If you are unsure about how to proceed, feel free to reach out to the instructor team for guidance.\n\nWindows: Download and run an installer from Python.org.\nMac: Install using homebrew. If you don’t have homebrew installed, follow the instructions from their webpage.\n\nbrew install python3\n\n\nAfter you run your install, make sure you check that the install is on your system PATH by running python3 --version again.\n\n\n\nThis section summarizes the official VS Code tutorial. For more detailed instructions and screenshots, see the source material\nFirst, install the Python extension for VS Code.\nOpen a terminal window in VS Code from the Terminal drop down in the main window. Run the following commands to initialize a project workspace in a directory called training. This example will show you how to do this locally. Later, we will show you how to set it up on the remote server with only one additional step.\nmkdir training\ncd training\ncode .\nNext, we will select the Python interpreter for the project. Open the Command Palette using Command + Shift + P (Control + Shift + P for windows). The Command Palette is a handy tool in VS Code that allows you to quickly find commands to VS Code, like editor commands, file edit and open commands, settings, etc. In the Command Palette, type “Python: Select Interpreter.” Push return to select the command, and then select the interpreter you want to use (your Python 3.X installation).\nFinally, download the Jupyter extension. You can create a test Jupyter Notebook document from the command pallete by typing “Create: New Jupyter Notebook” and selecting the command. This will open up a code editor pane with a notebook that you can test.\n\n\n\nTo make sure you can write and execute code in your project, create a Hello World test file.\n\nFrom the File Explorer toolbar, or using the terminal, create a file called hello.py\nAdd some test code to the file, and save\n\nmsg = \"Hello World\"\nprint(msg)\n\nExecute the script using either the Play button in the upper-right hand side of your window, or by running python3 hello.py in the terminal.\n\nFor more ways to run code in VS Code, see the tutorial\n\n\n\n\n\n\nThese written materials reflect the continuous development of learning materials at the Arctic Data Center and NCEAS to support individuals to understand, adopt, and apply ethical open science practices. In bringing these materials together we recognize that many individuals have contributed to their development. The primary authors are listed alphabetically in the citation below, with additional contributors recognized for their role in developing previous iterations of these or similar materials.\nThis work is licensed under a Creative Commons Attribution 4.0 International License.\nCitation: Matthew B. Jones, Bryce Mecum, S. Jeanette Clark, Samantha Csik. 2022. Scalable and Computationally Reproducible Approaches to Arctic Research.\nAdditional contributors: Amber E. Budden, Natasha Haycock-Chavez, Noor Johnson, Stephanie Hampton, Jim Regetz, Bryce Mecum, Julien Brun, Julie Lowndes, Erin McLean, Andrew Barrett, David LeBauer, Jessica Guo.\nThis is a Quarto book. To learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "sections/01-adc-intro.html",
    "href": "sections/01-adc-intro.html",
    "title": "1  Welcome and Introductions",
    "section": "",
    "text": "This course is one of three that we are currently offering, covering fundamentals of open data sharing, reproducible research, ethical data use and reuse, and scalable computing for reusing large data sets."
  },
  {
    "objectID": "sections/02-remote-computing.html",
    "href": "sections/02-remote-computing.html",
    "title": "2  Remote Computing",
    "section": "",
    "text": "Notes from Google Sheet (DELETE LATER)\n- Servers & Networking\n- IP addressing\n- Bash shell programming\n- SSH\n- Remote session in VS Code"
  },
  {
    "objectID": "sections/02-remote-computing.html#learning-objectives",
    "href": "sections/02-remote-computing.html#learning-objectives",
    "title": "2  Remote Computing",
    "section": "2.1 Learning Objectives",
    "text": "2.1 Learning Objectives\n\nUnderstand the basic architecture of computer networks\nBecome familiarized with Bash Shell programming to navigate your computer’s file system (??)\nLearn how to connect to a remote computer via a shell"
  },
  {
    "objectID": "sections/02-remote-computing.html#introduction",
    "href": "sections/02-remote-computing.html#introduction",
    "title": "2  Remote Computing",
    "section": "2.2 Introduction",
    "text": "2.2 Introduction\n\nScientific synthesis and our ability to effectively and efficiently work with big data depends on the use of computers & the internet\nVS Code + remote development on a cluster is easy and way faster than your local machine"
  },
  {
    "objectID": "sections/02-remote-computing.html#servers-networking",
    "href": "sections/02-remote-computing.html#servers-networking",
    "title": "2  Remote Computing",
    "section": "2.3 Servers & Networking",
    "text": "2.3 Servers & Networking\n\nHost computers connect via networking equipment and can send messages to each other over communication protocols (aka internet protocols)\n\nClient: the host initiating the request\nServer: the host responding to a request"
  },
  {
    "objectID": "sections/02-remote-computing.html#ip-addressing",
    "href": "sections/02-remote-computing.html#ip-addressing",
    "title": "2  Remote Computing",
    "section": "2.4 IP addressing",
    "text": "2.4 IP addressing\n\nHosts are assigned a unique numerical address used for all communication and routing called an Internet Protocol Address (IP Address). They look something like this: 128.111.220.7\nEach IP Address can be used to communicate over various “ports”, which allows multiple applications to communicate with a host without mixing up traffic\nIP addresses can be difficult to remember, so they are also assigned hostnames\n\nHostnames are handled through the global Domain Name System (DNS)\nClients first look up a hostname in DNS to find the IP address, then they open a connection the the IP address\n\naurora.nceas.ucsb.edu == 128.111.220.46 (UPDATE THIS WITH SERVER USED FOR COURSE?)"
  },
  {
    "objectID": "sections/02-remote-computing.html#bash-shell-programming",
    "href": "sections/02-remote-computing.html#bash-shell-programming",
    "title": "2  Remote Computing",
    "section": "2.5 Bash Shell Programming",
    "text": "2.5 Bash Shell Programming\n\nWhat is a shell? From Wikipedia\n\n\n“a computer program which exposes an operating system’s services to a human user or other programs. In general, operating system shells use either a command-line interface (CLI) or graphical user interface (GUI), depending on a computer’s role and particular operation.”\n\n\nWhat is Bash Shell? A command line tool (language) commonly used to manipulate files and directories\n\nMac: bash via the Terminal (QUESTION: Mac users may have to switch from zsh to bash? exec bash? or exec zsh to switch back)\nWindows: bash via Git Bash"
  },
  {
    "objectID": "sections/02-remote-computing.html#some-group-exercise",
    "href": "sections/02-remote-computing.html#some-group-exercise",
    "title": "2  Remote Computing",
    "section": "2.6 Some group exercise:",
    "text": "2.6 Some group exercise:\n\nNavigate file system (show that this is equivalent to using Finder/Windows version), create a file, edit file, etc.\n\npwd\ncd\nls\ntouch\nmkdir\n(Queston: Do we want/need to show all of these? Missing any important ones?)"
  },
  {
    "objectID": "sections/02-remote-computing.html#connecting-to-a-remote-computer-via-a-shell",
    "href": "sections/02-remote-computing.html#connecting-to-a-remote-computer-via-a-shell",
    "title": "2  Remote Computing",
    "section": "2.7 Connecting to a remote computer via a shell",
    "text": "2.7 Connecting to a remote computer via a shell\n\nYou can use a shell to gain accesss to and remotely control (manage/transfer files/etc) other computers. To do so, you’ll need the following:\n\nremote computer (e.g. server) turned on\nIP address or name of remote computer\nnecessary permissions to access the remote computer\n\nSecure Shell, or SSH, is often used for securely connecting to and running shell commands on a remote host\n\nTremendously simplifies remote computing\nSupported out-of-the-box on Linux and Macs"
  },
  {
    "objectID": "sections/02-remote-computing.html#exercise",
    "href": "sections/02-remote-computing.html#exercise",
    "title": "2  Remote Computing",
    "section": "2.8 Exercise:",
    "text": "2.8 Exercise:\n\nLaunch your Terimal program:\n\nMacOS: navigate to Applications | Utilities and open Terminal\nWindows: Navigate to Windows Start | Git and open Git Bash\nALTERNATIVELY, from VS Code: Two options to open a terminal program\n\nClick on Terminal | New Terminal in top menu bar\nClick on the + (dropdown menu) | bash in the bottom right corner (QUESTION: Not sure that is always open/available depending on user configurations??)\n\n\nConnect to a remote server (UPDATE THIS SECTION)\n\njones@powder:~$ ssh jones@aurora.nceas.ucsb.edu\njones@aurora.nceas.ucsb.edu's password: \njones@aurora:~$ \n\nChange your password (UPDATE THIS SECTION)\n\njones@aurora:~$ passwd\nChanging password for jones.\n(current) UNIX password: \nEnter new UNIX password: \nRetype new UNIX password: \n\ncreate python script on server | write/execute some code | etc"
  },
  {
    "objectID": "sections/03-python-intro.html",
    "href": "sections/03-python-intro.html",
    "title": "3  Python Programming on Clusters",
    "section": "",
    "text": "Basic Python review\nUsing virtual environments\nWriting in Jupyter notebooks\nWriting functions in Python"
  },
  {
    "objectID": "sections/03-python-intro.html#introduction",
    "href": "sections/03-python-intro.html#introduction",
    "title": "3  Python Programming on Clusters",
    "section": "3.2 Introduction",
    "text": "3.2 Introduction\n\nVS Code + remote development on a cluster is easy and way faster than your local machine\nJupyter is a great way to do literate analysis\nFunctions provide ways to reuse your code across notebooks/projects"
  },
  {
    "objectID": "sections/03-python-intro.html#python-on-the-cluster",
    "href": "sections/03-python-intro.html#python-on-the-cluster",
    "title": "3  Python Programming on Clusters",
    "section": "3.3 Python on the cluster",
    "text": "3.3 Python on the cluster\n\nConnect to the server\nStart a training project and pick interpreter (this could also go in Sam’s session)\nCreate and execute hello.py\n\nfrom the IDE as a whole\nfrom IDE line by line\nfrom the terminal"
  },
  {
    "objectID": "sections/03-python-intro.html#virtual-environments",
    "href": "sections/03-python-intro.html#virtual-environments",
    "title": "3  Python Programming on Clusters",
    "section": "3.4 Virtual Environments",
    "text": "3.4 Virtual Environments\n\ninstall virtualenvwrapper\nmodify .bash_profile to point to installs\ncheck it was installed correctly\nmake virtual env scomp\ninstall course requirements into that env\ndeactivate and workon"
  },
  {
    "objectID": "sections/03-python-intro.html#brief-overview-of-python-syntax",
    "href": "sections/03-python-intro.html#brief-overview-of-python-syntax",
    "title": "3  Python Programming on Clusters",
    "section": "3.5 Brief overview of python syntax",
    "text": "3.5 Brief overview of python syntax\n\nlists, arrays, dictionaries, associative arrays"
  },
  {
    "objectID": "sections/03-python-intro.html#jupyter-notebooks",
    "href": "sections/03-python-intro.html#jupyter-notebooks",
    "title": "3  Python Programming on Clusters",
    "section": "3.6 Jupyter notebooks",
    "text": "3.6 Jupyter notebooks\n\nCreate a notebook\nLoad in some libraries (pandas, numpy, scipy, matplotlib)\nRead in a csv\ngroup and summarize by a variable\ncreate a simple plot"
  },
  {
    "objectID": "sections/03-python-intro.html#functions",
    "href": "sections/03-python-intro.html#functions",
    "title": "3  Python Programming on Clusters",
    "section": "3.7 Functions",
    "text": "3.7 Functions\n\ncreate myplot.py\nwrite myplot() function to create the same plot we did in section above\nload myplot into jupyter notebook (from myplot.py import myplot)\nreplace old plot method with new function\nmore to come in Bryce’s section"
  },
  {
    "objectID": "sections/03-python-intro.html#resources",
    "href": "sections/03-python-intro.html#resources",
    "title": "3  Python Programming on Clusters",
    "section": "3.8 Resources",
    "text": "3.8 Resources"
  },
  {
    "objectID": "sections/04-parallel-programming.html#introduction",
    "href": "sections/04-parallel-programming.html#introduction",
    "title": "4  Pleasingly Parallel Programming",
    "section": "4.2 Introduction",
    "text": "4.2 Introduction"
  },
  {
    "objectID": "sections/05-adc-data-publishing.html#introduction",
    "href": "sections/05-adc-data-publishing.html#introduction",
    "title": "5  Documenting and Publishing Data",
    "section": "5.2 Introduction",
    "text": "5.2 Introduction"
  },
  {
    "objectID": "sections/10-geopandas.html",
    "href": "sections/10-geopandas.html",
    "title": "6  Spatial and Image Data Using GeoPandas",
    "section": "",
    "text": "Reading raster data with rasterasterio\nUsing geopandas and rasterasterio to process raster data\nWorking with raster and vector data together"
  },
  {
    "objectID": "sections/10-geopandas.html#introduction",
    "href": "sections/10-geopandas.html#introduction",
    "title": "6  Spatial and Image Data Using GeoPandas",
    "section": "6.2 Introduction",
    "text": "6.2 Introduction\n\nRaster vs vector data\nWhat is a projection\nProcessing overview\n\ngoal is to calculate vessel distance per commercial fishing area"
  },
  {
    "objectID": "sections/10-geopandas.html#pre-processing-raster-data",
    "href": "sections/10-geopandas.html#pre-processing-raster-data",
    "title": "6  Spatial and Image Data Using GeoPandas",
    "section": "6.3 Pre-processing raster data",
    "text": "6.3 Pre-processing raster data\nThis is a test to make sure we can run some code in this notebook.\nimport geopandas as gpd\nimport rasterio\nimport rasterio.mask\nfrom rasterstats import zonal_stats\nfrom shapely.geometry import Polygon\nimport requests\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nurl_sf = 'https://cn.dataone.org/cn/v2/resolve/urn:uuid:dd61089d-f50e-4d87-9b75-6b4e2bd24776'\n\nresponse_sf = requests.get(url_sf)\nopen(\"Coastal_2020_12.tif\", \"wb\").write(response_sf.content)\n\n1132748\n\n\n\nwith rasterio.open(\"Coastal_2020_12.tif\") as dem_src:\n    ships = dem_src.read(1)\n    ships_meta = dem_src.profile\n\nplt.imshow(ships)\nprint(ships_meta)\n\n{'driver': 'GTiff', 'dtype': 'float32', 'nodata': -3.3999999521443642e+38, 'width': 3087, 'height': 2308, 'count': 1, 'crs': CRS.from_epsg(3338), 'transform': Affine(999.7994153462766, 0.0, -2550153.29233849,\n       0.0, -999.9687691991521, 2711703.104608573), 'tiled': False, 'compress': 'lzw', 'interleave': 'band'}\n\n\n\n\n\n\nread in the data\nclip to an extent that runs roughly from Bristol Bay to Prince William Sound"
  },
  {
    "objectID": "sections/10-geopandas.html#distance-per-commercial-area",
    "href": "sections/10-geopandas.html#distance-per-commercial-area",
    "title": "6  Spatial and Image Data Using GeoPandas",
    "section": "6.4 Distance per commercial area",
    "text": "6.4 Distance per commercial area\n\nurl = 'https://knb.ecoinformatics.org/knb/d1/mn/v2/object/urn%3Auuid%3A7c942c45-1539-4d47-b429-205499f0f3e4'\n\nresponse = requests.get(url)\nopen(\"Alaska_Commercial_Salmon_Boundaries.gpkg\", \"wb\").write(response.content)\n\n36544512\n\n\n\n6.4.1 Read in fishing districts\ncomm = gpd.read_file(\"Alaska_Commercial_Salmon_Boundaries.gpkg\")\nReproject the data\ncomm.crs\ncomm_3338 = comm.to_crs(\"EPSG:3338\")\nGet the bounding box as it’s own GeoDataFrame\n# function to return polygon\ndef bbox(long0, lat0, lat1, long1):\n  return Polygon([[long0, lat0], [long1,lat0], [long1,lat1], [long0, lat1]])\n\n\ncoords = bbox(comm_3338.total_bounds[0], comm_3338.total_bounds[1], comm_3338.total_bounds[2], comm_3338.total_bounds[3])\n\nbbox_crop = gpd.GeoDataFrame(pd.DataFrame(['p1'], columns = ['geom']),\n    crs = 'EPSG:3338',\n    geometry = [coords])\nRead in raster again cropped to bounding box - bounding box doesn’t quite match what I expected\nwith rasterio.open(\"Coastal_2020_12.tif\") as src:\n    out_image, out_transform = rasterio.mask.mask(src, bbox_crop[\"geometry\"], crop=True)\n    out_meta = src.meta\n\nout_meta.update({\"driver\": \"GTiff\",\n                 \"height\": out_image.shape[1],\n                 \"width\": out_image.shape[2],\n                 \"transform\": out_transform})\n\nwith rasterio.open(\"Coastal_2020_12_masked.tif\", \"w\", **out_meta) as dest:\n    dest.write(out_image)\n\nplt.imshow(out_image[0])\n\n<matplotlib.image.AxesImage at 0x1257d74f0>"
  },
  {
    "objectID": "sections/10-geopandas.html#calculate-total-distance-per-fishing-area",
    "href": "sections/10-geopandas.html#calculate-total-distance-per-fishing-area",
    "title": "6  Spatial and Image Data Using GeoPandas",
    "section": "6.5 Calculate total distance per fishing area",
    "text": "6.5 Calculate total distance per fishing area\nzs = zonal_stats(comm_3338, \"Coastal_2020_12_masked.tif\", stats = \"sum\")\nWrangle the data and reattach distances to the original polygons\ndist = [d['sum'] for d in zs]\n\nres = pd.DataFrame({'STAT_AREA' : comm_3338[\"STAT_AREA\"],\n                    'distance' : dist})\n\nres_summary = res.dropna(thresh = 0).query(\"distance > 0\")\n\nres_full = comm_3338.merge(res_summary, on = \"STAT_AREA\", how = 'left')\nGroup by/summarize across another variable\n\nres_full.plot(column = \"distance\", legend = True)\n\n<AxesSubplot:>"
  }
]