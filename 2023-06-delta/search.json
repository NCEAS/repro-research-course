[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "NCEAS Open Science Synthesis for the Delta Science Program",
    "section": "",
    "text": "Overview"
  },
  {
    "objectID": "index.html#about-this-training",
    "href": "index.html#about-this-training",
    "title": "NCEAS Open Science Synthesis for the Delta Science Program",
    "section": "About this training",
    "text": "About this training\nNCEAS Open Science Synthesis training consists of three 1-week long workshops, geared towards early career researchers. Participants engage in a mix of lectures, exercises, and synthesis research groups to undertake synthesis while learning and implementing best practices for open data science."
  },
  {
    "objectID": "index.html#why-nceas",
    "href": "index.html#why-nceas",
    "title": "NCEAS Open Science Synthesis for the Delta Science Program",
    "section": "Why NCEAS",
    "text": "Why NCEAS\nThe National Center for Ecological Analysis and Synthesis (NCEAS), a research affiliate of UCSB, is a leading expert on interdisciplinary data science and works collaboratively to answer the world’s largest and most complex questions. The NCEAS approach leverages existing data and employs a team science philosophy to squeeze out all potential insights and solutions efficiently - this is called synthesis science.\nNCEAS has over 25 years of success with this model among working groups and environmental professionals. Together with the Delta Science Program and the Delta Stewardship Council we are excited to pass along skills, workflows, mindsets learn throughout the years."
  },
  {
    "objectID": "index.html#week-1-open-data-and-synthesis",
    "href": "index.html#week-1-open-data-and-synthesis",
    "title": "NCEAS Open Science Synthesis for the Delta Science Program",
    "section": "Week 1: Open Data and Synthesis",
    "text": "Week 1: Open Data and Synthesis\nJune 26-30, 2023\nLearning Objectives:\n\nImplement reproducible scientific workflows throughout all aspects of a project\nIncrease your familiarity and confidence with data science tools\nEffectively manage and wrangle data using tidy data practices\nAccessing, interpreting and developing metadata for synthesis research\nOrganize and initiate synthesis projects"
  },
  {
    "objectID": "index.html#schedule",
    "href": "index.html#schedule",
    "title": "NCEAS Open Science Synthesis for the Delta Science Program",
    "section": "Schedule",
    "text": "Schedule"
  },
  {
    "objectID": "index.html#next-trainings",
    "href": "index.html#next-trainings",
    "title": "NCEAS Open Science Synthesis for the Delta Science Program",
    "section": "Next trainings",
    "text": "Next trainings\n\nWeek 2: Open Tools for Analysis and Visualization\nAug 28 - Sep 1, 2023\n\nStrengthen core knowledge of version control and workflow\nIntroduce metaanalysis concepts and tools\nApproaches for geospatial visualization\nData tools for qualitative data\n\n\n\nWeek 3: Scaling up and presenting synthesis\nOctober 23 – 27, 2023\n\nHandling missing data\nBig data workflows and parallel computing\nBuilding scientific websites with R and Shiny\nSynthesis presentations and next steps"
  },
  {
    "objectID": "index.html#code-of-conduct",
    "href": "index.html#code-of-conduct",
    "title": "NCEAS Open Science Synthesis for the Delta Science Program",
    "section": "Code of Conduct",
    "text": "Code of Conduct\nBy participating in this activity you agree to abide by the NCEAS Code of Conduct."
  },
  {
    "objectID": "index.html#about-this-book",
    "href": "index.html#about-this-book",
    "title": "NCEAS Open Science Synthesis for the Delta Science Program",
    "section": "About this book",
    "text": "About this book\nThese written materials are the result of a continuous and collaborative effort at NCEAS with the support of DataONE, to help researchers make their work more transparent and reproducible. This work began in the early 2000’s, and reflects the expertise and diligence of many, many individuals. The primary authors for this version are listed in the citation below, with additional contributors recognized for their role in developing previous iterations of these or similar materials.\nThis work is licensed under a Creative Commons Attribution 4.0 International License.\nCitation: Halina Do-Linh, Carmen Galaz García, Matthew B. Jones, Camila Vargas Poulsen. 2023. Open Science Synthesis training Week 1. NCEAS Learning Hub & Delta Stewardship Council.\nAdditional contributors: Ben Bolker, Julien Brun, Amber E. Budden, Jeanette Clark, Samantha Csik, Stephanie Hampton, Natasha Haycock-Chavez, Samanta Katz, Julie Lowndes, Erin McLean, Bryce Mecum, Deanna Pennington, Karthik Ram, Jim Regetz, Tracy Teal, Daphne Virlar-Knight, Leah Wasser.\nThis is a Quarto book. To learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "session_01.html#learning-objectives",
    "href": "session_01.html#learning-objectives",
    "title": "1  RStudio Server Setup",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nPractice creating an R Project\nOrganize an R Project for effective project management\nUnderstand how to move in an R Project using paths and working directories"
  },
  {
    "objectID": "session_01.html#before-we-start",
    "href": "session_01.html#before-we-start",
    "title": "1  RStudio Server Setup",
    "section": "1.1 Before we start",
    "text": "1.1 Before we start\n\n1.1.1 Non-Verbal Feedback\nWe’ll be using the Zoom “Non Verbal Feedback” buttons throughout this session. We will ask you to put a green check by your name when you’re all set and ready to move on, and a red x by your name if you’re stuck or need assistance. These buttons can be found in the Reaction menu on the toolbar. When you’re asked to answer using these buttons, please ensure that you select one so that the instructor has the feedback that they need to either continue the lesson or pause until everyone gets back on the same page.\n\n\n\n1.1.2 Questions and Getting Help\nWhen you need to ask a question, please do so in one of the following ways:\n\nTurn your mic on and ask. If you are uncomfortable interrupting the instructor, you may also raise your virtual hand (in the Reaction menu) and the session facilitator will ask the instructor to pause and call upon you.\nAsk your question in the chat\n\nIf you have an issue/error and get stuck, you can ask for help in the following ways:\n\nTurn your mic on and ask for help. See also above regarding the use of a virtual raised hand.\nLet one of the instructors know through the chat\nIf prompted to do so, put a red X next to your name as your status in the participant window.\nIf you have an issue that requires in-depth trouble shooting, please let us know and we will coordinate a time with you after this call."
  },
  {
    "objectID": "session_01.html#logon-to-the-rstudio-server",
    "href": "session_01.html#logon-to-the-rstudio-server",
    "title": "1  RStudio Server Setup",
    "section": "1.2 Logon to the RStudio Server",
    "text": "1.2 Logon to the RStudio Server\nTo prevent us from spending most of this lesson troubleshooting the myriad of issues that can arise when setting up the R, RStudio, and git environments, we have chosen to have everyone work on a remote server with all of the software you need installed. We will be using a special kind of RStudio just for servers called RStudio Server. If you have never worked on a remote server before, you can think of it like working on a different computer via the internet. Note that the server has no knowledge of the files on your local filesystem, but it is easy to transfer files from the server to your local computer, and vice-versa, using the RStudio server interface.\n\n\n\n\n\n\nServer Setup\n\n\n\nYou should have received an email prompting you to change your password for your server account. If you did not, please put up a post-it and someone will help you.\nAfter you have successfully changed your password log in at: https://included-crab.nceas.ucsb.edu/"
  },
  {
    "objectID": "session_01.html#programming-in-r",
    "href": "session_01.html#programming-in-r",
    "title": "1  RStudio Server Setup",
    "section": "1.3 Programming in R",
    "text": "1.3 Programming in R\n\n\n\nArtwork by Allison Horst\n\n\nThere is a vibrant community out there that is collectively developing increasingly easy to use and powerful open source programming tools. The changing landscape of programming is making learning how to code easier than it ever has been. Incorporating programming into analysis workflows not only makes science more efficient, but also more computationally reproducible. In this course, we will use the programming language R, and the accompanying integrated development environment (IDE) RStudio. R is a great language to learn for data-oriented programming because it is widely adopted, user-friendly, and (most importantly) open source!\nSo what is the difference between R and RStudio? Here is an analogy to start us off. If you were a chef, R is a knife. You have food to prepare, and the knife is one of the tools that you’ll use to accomplish your task.\nAnd if R were a knife, RStudio is the kitchen. RStudio provides a place to do your work! Other tools, communication, community, it makes your life as a chef easier. RStudio makes your life as a researcher easier by bringing together other tools you need to do your work efficiently - like a file browser, data viewer, help pages, terminal, community, support, the list goes on. So it’s not just the infrastructure (the user interface or IDE), although it is a great way to learn and interact with your variables, files, and interact directly with git. It’s also data science philosophy, R packages, community, and more. Although you can prepare food without a kitchen and we could learn R without RStudio, that’s not what we’re going to do. We are going to take advantage of the great RStudio support, and learn R and RStudio together.\nSomething else to start us off is to mention that you are learning a new language here. It’s an ongoing process, it takes time, you’ll make mistakes, it can be frustrating, but it will be overwhelmingly awesome in the long run. We all speak at least one language; it’s a similar process, really. And no matter how fluent you are, you’ll always be learning, you’ll be trying things in new contexts, learning words that mean the same as others, etc, just like everybody else. And just like any form of communication, there will be miscommunication that can be frustrating, but hands down we are all better off because of it.\nWhile language is a familiar concept, programming languages are in a different context from spoken languages and you will understand this context with time. For example: you have a concept that there is a first meal of the day, and there is a name for that: in English it’s “breakfast.” So if you’re learning Spanish, you could expect there is a word for this concept of a first meal. (And you’d be right: “desayuno”). We will get you to expect that programming languages also have words (called functions in R) for concepts as well. You’ll soon expect that there is a way to order values numerically. Or alphabetically. Or search for patterns in text. Or calculate the median. Or reorganize columns to rows. Or subset exactly what you want. We will get you to increase your expectations and learn to ask and find what you’re looking for."
  },
  {
    "objectID": "session_01.html#rstudio-ide",
    "href": "session_01.html#rstudio-ide",
    "title": "1  RStudio Server Setup",
    "section": "1.4 RStudio IDE",
    "text": "1.4 RStudio IDE\nLet’s take a tour of the RStudio interface.\n\nNotice the default panes:\n\nConsole (entire left)\nEnvironment/History (tabbed in upper right)\nFiles/Plots/Packages/Help (tabbed in lower right)\n\n\n\n\n\n\n\nQuick Tip\n\n\n\nYou can change the default location of the panes, among many other things, see Customizing RStudio."
  },
  {
    "objectID": "session_01.html#create-an-r-project",
    "href": "session_01.html#create-an-r-project",
    "title": "1  RStudio Server Setup",
    "section": "1.5 Create an R Project",
    "text": "1.5 Create an R Project\nIn this course, we are going to be using an R project to organize our work. An R project is tied to a directory on your local computer, and makes organizing your work and collaborating with others easier.\nThe Big Idea: using an R project is a reproducible research best practice because it bundles all your work within a working directory. Consider your current data analysis workflow. Where do you import you data? Where do you clean and wrangle it? Where do you create graphs, and ultimately, a final report? Are you going back and forth between multiple software tools like Microsoft Excel, JMP, and Google Docs? An R project and the tools in R that we will talk about today will consolidate this process because it can all be done (and updated) in using one software tool, RStudio, and within one R project.\n\n\n\n\n\n\nR Project Setup\n\n\n\n\nIn the “File” menu, select “New Project”\nClick “New Directory”\nClick “New Project”\nUnder “Directory name” type: training_{USERNAME} (i.e. training_vargas)\nLeave “Create Project as subdirectory of:” set to ~\nClick “Create Project”\n\nRStudio should open your new project automatically after creating it. One way to check this is by looking at the top right corner and checking for the project name."
  },
  {
    "objectID": "session_01.html#organizing-an-r-project",
    "href": "session_01.html#organizing-an-r-project",
    "title": "1  RStudio Server Setup",
    "section": "1.6 Organizing an R Project",
    "text": "1.6 Organizing an R Project\nWhen starting a new research project, step 1 is to create an R Project for it (just like we have here!). The next step is to then populate that project with relevant directories. There are many tools out there that can do this automatically. Some examples are rrtools or usethis::create_package(). The goal is to organize your project so that it is a compendium of your research. This means that the project has all of the digital parts needed to replicate your analysis, like code, figures, the manuscript, and data access.\nSome common directories are:\n\n\n\n\ndata: where we store our data (often contains subdirectories for raw, processed, and metadata data)\nR: contains scripts for cleaning or wrangling, etc. (some find this name misleading if their work has other scripts beyond the R programming language, in which case they call this directory scripts)\nplots or figs: generated plots, graphs, and figures\ndocs: summaries or reports of analysis or other relevant project information\n\nDirectory organization will vary from project to project, but the ultimate goal is to create a well organized project for both reproducibility and collaboration."
  },
  {
    "objectID": "session_01.html#moving-in-an-r-project-using-paths-working-directories",
    "href": "session_01.html#moving-in-an-r-project-using-paths-working-directories",
    "title": "1  RStudio Server Setup",
    "section": "1.7 Moving in an R Project using Paths & Working Directories",
    "text": "1.7 Moving in an R Project using Paths & Working Directories\n\nNow that we have your project created (and notice we know it’s an R Project because we see a .Rproj file in our Files pane), let’s learn how to move in a project. We do this using paths.\nThere are two types of paths in computing: absolute paths and relative paths.\n\nAn absolute path always starts with the root of your file system and locates files from there. The absolute path to my project directory is: /home/vargas-poulsen/training_vargas\nRelative paths start from some location in your file system that is below the root. Relative paths are combined with the path of that location to locate files on your system. R (and some other languages like MATLAB) refer to the location where the relative path starts as our working directory.\n\nRStudio projects automatically set the working directory to the directory of the project. This means that you can reference files from within the project without worrying about where the project directory itself is. If I want to read in a file from the data directory within my project, the code to do this would be read.csv(\"data/samples.csv\") (path relative to my R project) as opposed to read.csv(\"/home/vargas-poulsen/training_vargas/data/samples.csv\") (absolute path of my home directory).\nThis is not only convenient for you, but also when working collaboratively. For example if Matt makes a copy of my R project that I have published on GitHub, and I am using relative paths, he can run my code exactly as I have written it, without going back and changing /home/vargas-poulsen/training_vargas/data/samples.csv to /home/jones/training_jones/data/samples.csv.\nNote that once you start working in projects you should basically never need to run the setwd() command. If you are in the habit of doing this, stop and take a look at where and why you do it. Could leveraging the working directory concept of R projects eliminate this need? Almost definitely!\n\n\nsetwd() sets your working directory to specified file path (aka directory).\nSimilarly, think about how you work with absolute paths. Could you leverage the working directory of your R project to replace these with relative paths and make your code more portable? Probably!"
  },
  {
    "objectID": "session_01.html#rstudio-personal-setup",
    "href": "session_01.html#rstudio-personal-setup",
    "title": "1  RStudio Server Setup",
    "section": "1.8 Setting up R and RStudio on your Computer",
    "text": "1.8 Setting up R and RStudio on your Computer\n\n1.8.1 Check your R Version\nFor this course, we used the R Version 4.2.2. To check the R Version of your personal computer run this in the Console: R.version$version.string. If you need to download R onto your personal computer or update it, you can do so from CRAN (The Comprehensive R Archive Network).\n\n\n1.8.2 Check your RStudio Version\nFor this course, we used the RStudio Version released in December 2022. To check the RStudio Version of your personal computer run this in the Console: RStudio.Version()$version. If you need to download RStudio onto your personal computer or update it, you can do so from Posit. Note you may need to update your computer’s software to download the newest version of RStudio.\nAnother way to check for RStudio updates is to click “Help” and then “Check for Updates”. Follow the prompts.\n\n\n1.8.3 Install Packages\nIn the code chunk below, we have listed out the packages we used for this course. You’re welcome to install each package one-by-one by calling the install.packages(\"package_name\") function. Or you can copy and paste this code chunk and run it which includes a for loop that will check if a package is installed on your personal computer and if not, it will install it. We have also included a line of code that will update our packages. Running this code chunk may take a few minutes.\n\ncourse_packages &lt;- c(\"dplyr\",\n                     \"DT\",\n                     \"forcats\",\n                     \"ggplot2\",\n                     \"ggmap\",\n                     \"knitr\",\n                     \"leaflet\",\n                     \"lubridate\",\n                     \"readr\",\n                     \"renv\",\n                     \"rrtools\",\n                     \"sf\",\n                     \"scales\",\n                     \"tidyr\",\n                     \"usethis\")\n\nfor (course_packages in course_packages) {\n    \n    if (!(course_packages %in% installed.packages())) { install.packages(course_packages) }\n    \n    }\n\nrm(course_packages) # remove object from Global Environment\n\n# update any out-of-date packages\nupdate.packages(ask=FALSE)"
  },
  {
    "objectID": "session_02.html#learning-objectives",
    "href": "session_02.html#learning-objectives",
    "title": "2  Git and GitHub Setup",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nSet global options in your .gitconfig file\nPractice how to set up GitHub Authentication using a Personal Access Token (PAT)"
  },
  {
    "objectID": "session_02.html#set-up-global-options-in-git",
    "href": "session_02.html#set-up-global-options-in-git",
    "title": "2  Git and GitHub Setup",
    "section": "2.1 Set up global options in Git",
    "text": "2.1 Set up global options in Git\nBefore using Git, you need to tell it who you are, also known as setting the global options. To do this, we will be setting the global options in the Terminal.\n\n\n\n\n\n\nWhat’s the Terminal?\n\n\n\nTechnically, the Terminal is an interface for the shell, a computer program. To put that simply, we use the Terminal to tell a computer what to do. This is different from the Console in RStudio, which interprets R code and returns a value.\n\n\nTo get started, let’s open a new Terminal window in RStudio. Do this by clicking Tools &gt; Terminal &gt; New Terminal.\nA Terminal tab should now be open where your Console usually is.\n\n\n\n\n\n\nDon’t be afraid to dip your toes in the Terminal\n\n\n\nMost of our git operations will be done in RStudio, but there are some situations where you must work in the Terminal and use command line. It may be daunting to code in the Terminal, but as your comfort increases over time, you might find you prefer it. Either way, it’s beneficial to learn enough command line and to feel comfortable in the Terminal.\n\n\nLet’s start by adding your user name to the global options. Type the following into the command prompt, with your exact GitHub username, and press enter:\ngit config --global user.name \"my_user_name\"\n\n\nNote that if it ran successfully, it will look like nothing happened. We will check at the end to make sure it worked.\nNext, enter the following line, with the email address you used when you created your account on github.com:\ngit config --global user.email \"my_email@nceas.ucsb.edu\"\n\n\n\n\n\n\nCase and spelling matters!\n\n\n\nWhen you add your username and email to the global options you must use the exact same spelling and case that you used on GitHub otherwise, Git won’t be able to sync to your account.\n\n\nNext, we will set our credentials to not time out for a very long time. This is related to how our server operating system handles credentials - not doing this will make your Personal Access Token (PAT, which we will set up in the next section) expire immediately on the system, even though it is actually valid for at least a month.\ngit config --global credential.helper 'cache --timeout=10000000'\nNext, we will set the default branch name to main for any new repositories that are created moving forward. Why are we doing this? Previously, the default branch name was master and this racist terminology for git branches motivates us to update our default branch to main instead.\ngit config --global init.defaultBranch main\nFinally, check to make sure everything looks correct by entering this command, which will return the global options you have set.\ngit config --global --list"
  },
  {
    "objectID": "session_02.html#github-authentication",
    "href": "session_02.html#github-authentication",
    "title": "2  Git and GitHub Setup",
    "section": "2.2 GitHub Authentication",
    "text": "2.2 GitHub Authentication\nGitHub recently deprecated password authentication for accessing repositories, so we need to set up a secure way to authenticate.\nThe book Happy Git and GitHub for the useR has a wealth of information related to working with Git in R, and these instructions are based off of Chapter 9 Personal access token for HTTPS.\nWe will be using a Personal Access Token (PAT) in this course. For better security and long term use, we recommend taking the extra steps to set up SSH keys (check out Chapter 10 Set up Keys for SSH).\n\n\n\n\n\n\nSetting up your PAT\n\n\n\n\nRun usethis::create_github_token() in the Console.\nA new browser window should open up to GitHub, showing all the scopes options. You can review the scopes, but you don’t need to worry about which ones to select this time. Using create_github_token() automatically pre-selects some recommended scopes. Go ahead and scroll to the bottom and click “Generate Token”.\nCopy the generated token.\nBack in RStudio, run gitcreds::gitcreds_set() in the Console.\nPaste your PAT when the prompt asks for it.\nLast thing, run usethis::git_sitrep() in the Console to check your Git configuration and that you’ve successful stored your PAT.\n\n\n\nCongrats! Now you’ve setup your authentication you should be able to work with GitHub in RStudio now."
  },
  {
    "objectID": "session_03.html#learning-objectives",
    "href": "session_03.html#learning-objectives",
    "title": "3  Literate Analysis with Quarto",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nIntroduce literate analysis using Quarto (an extension of RMarkdown’s features)\nLearn markdown syntax and run R code using Quarto\nBuild and render an example analysis"
  },
  {
    "objectID": "session_03.html#introduction",
    "href": "session_03.html#introduction",
    "title": "3  Literate Analysis with Quarto",
    "section": "3.1 Introduction",
    "text": "3.1 Introduction"
  },
  {
    "objectID": "session_03.html#literate-programming",
    "href": "session_03.html#literate-programming",
    "title": "3  Literate Analysis with Quarto",
    "section": "3.2 Literate Programming",
    "text": "3.2 Literate Programming\nAll too often, computational methods are written in such a way as to be borderline incomprehensible even to the person who originally wrote the code! The reason for this is obvious, computers interpret information very differently than people do. In 1984, Donald Knuth proposed a reversal of the programming paradigm by introducing the concept of Literate Programming (Knuth 1984).\n\n“Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do.”\n\nIf our aim is to make scientific research more transparent, the appeal of this paradigm reversal is immediately apparent. By switching to a literate analysis model, you help enable human understanding of what the computer is doing. As Knuth describes, in the literate analysis model, the author is an “essayist” who chooses variable names carefully, explains what they mean, and introduces concepts in the analysis in a way that facilitates understanding.\nQuarto and RMarkdown are an excellent way to generate literate analysis, and a reproducible workflow. These types of files, combine R the programming language, and markdown, a set of text formatting directives.\nIn an R script, the language assumes that you are writing R code, unless you specify that you are writing prose (using a comment, designated by #). The paradigm shift of literate analysis comes in the switch to RMarkdown or Quarto, where instead of assuming you are writing code, they assume that you are writing prose unless you specify that you are writing code. This, along with the formatting provided by markdown, encourages the “essayist” to write understandable prose to accompany the code that explains to the human-beings reading the document what the author told the computer to do. This is in contrast to writing just R code, where the author telling to the computer what to do with maybe a smattering of terse comments explaining the code to a reader.\nBefore we dive in deeper, let’s look at an example of what a rendered literate analysis can look like using a real example. Here is an example of an analysis workflow written using RMarkdown. Note that if this analysis would be in Quarto, the render version it would be similar, except for formatting and layout (eg: the default font in Quarto is different).\nThere are a few things to notice about this document, which assembles a set of similar data sources on salmon brood tables with different formatting into a single data source.\n\nIt introduces the data sources using in-line images, links, interactive tables, and interactive maps.\nAn example of data formatting from one source using R is shown.\nThe document executes a set of formatting scripts in a directory to generate a single merged file.\nSome simple quality checks are performed (and their output shown) on the merged data.\nSimple analysis and plots are shown.\n\nIn addition to achieving literate analysis, this document also represents a reproducible analysis. Because the entire merging and quality control of the data is done using the R code in the Quarto file, if a new data source and formatting script are added, the document can be run all at once with a single click to re-generate the quality control, plots, and analysis of the updated data.\n\n\n\n\n\n\nA note on reproducibility\n\n\n\nReproducible analysis allow you to automatize how the figures and the statistics in your analysis are generated. This process also helps your collaborators, your readers and your future self to follow your code trail the leads to the original data, increasing the transparency of your science.\nLiterate analysis help reduce the mistakes from copying and pasting across software, keeps results and models in sync, and allows you to provide interested readers with more information about the different approaches and analyses you tried before coming up with the final results."
  },
  {
    "objectID": "session_03.html#rmarkdown-and-quarto",
    "href": "session_03.html#rmarkdown-and-quarto",
    "title": "3  Literate Analysis with Quarto",
    "section": "3.3 RMarkdown and Quarto",
    "text": "3.3 RMarkdown and Quarto\nYou can identify a Quarto file with the .qmd extension. On the other hand, an RMarkdown file has a .Rmd extension. Both have similar structures and both combine prose with code.Quarto provides a rich support to languages other than R such as Python, Observable, and Julia. It also excels in formatting and layout. Allowing users to customize in details the looks of the rendered documents. On the other hand, RMarkdown is compatible with some languages that Quarto is not, for example bash. Quarto and Rmarkdown are amazing tools to use for collaborative research. During this course e will spend some time learning and using the basics of Quarto and provide some comparisons to RMarkdown.\n\nNow, let’s take a look at the structure of each of these files. The both look for the most part the same with minor differences.\n\n\nFinally, lets compare each of these files when knitted/rendered.\n\n\nAgain, we see similar outcoumes, with minor differences mainly in formatting (font, style of showing code chunks, etc.)\nBoth type of documents have three main components:\n\nYAML metadata to guide the document’s build process\nCode chunks to run\nProse (Text to display)\n\nToday we are going to use Quarto to run some analysis on data. We are specifically going to focus on the code chunk and text components. We will discuss more about the how the YAML works in an Quarto later in the course.\n\n\n\n\n\n\nThe YAML\n\n\n\nIs the document’s metadata which sets guidelines on how your want the output of your document to look like. It is located at the top of your file, delineated by three dashes (---) at the top and at the bottom of it. It can be used to specify:\n\nCharacteristics of your documents such at title, author, date of creation.\nArgument to pass on the building process to control the format of the output.\nAdd additional information such as the bibliography file (and formatting of the references)\nSpecific parameters for your report (eg: just used a subset of the data)."
  },
  {
    "objectID": "session_03.html#a-quarto-document",
    "href": "session_03.html#a-quarto-document",
    "title": "3  Literate Analysis with Quarto",
    "section": "3.4 A Quarto Document",
    "text": "3.4 A Quarto Document\nLet’s open an Quarto file following the instructions below.\n\n\n\n\n\n\nSetup\n\n\n\n\nOpen a new Quarto file using the following prompts: File &gt; New File &gt; Quarto Document\nA popup window will appear.\nGive your file a new title, e.g “Introduction to Quarto”.\nLeave the output format as HTML and Engine set to Knitr.\nThen click the “Create” button.\n\n\n\nThe first thing to notice is that by opening a file, we see the fourth pane of the RStudio pops up. This is our Quarto document which is essentially a text editor. We also see in the upper left side that we are looking at the document under the “Visual editor”. This is probably a familiar way of looking at a text document. To introduce the markdown syntax, we re going to move to the source editor and then come back to the visual editor. In the upper left corner, click on Source. See how the formatting changed? In the Source editor we are looking at the same text, but in markdown syntax. The visual editor on the other hand, allows us to see how markdown is rendered, therefore how is it going to look in our output document.\nLet’s have a look at this file — As we saw in the examples above, it looks a little different than a R script. It’s not blank; there is some initial text already provided for you. Lets identify the three main components we introduces before. We have the YAML a the top, in between the two sets of dashed lines. Then we also see white and grey sections. The gray sections are R code chunks and the white sections are plain text.\nLet’s go ahead and render this file by clicking the “Render” button, next to the blue arrow at the top of the Quarto file. When you first click this button, RStudio will prompt you to save this file. Save it in the top level of your home directory on the server, and name it something that you will remember (like quarto-intro.Rmd).\n\n\n\nWhat do you notice between the two?\nFirst, the render process produced a second file (an HTML file) that popped up in a second window in the browser. You’ll also see this file in your directory with the same name as your qmd, but with the .html extension. In it’s simplest format, Quarto files come in pairs (same than RMarkdown files) the Quarto document, and its rendered version. In this case, we are rendering, the file into HTML. You can also knit to PDF or Word files and others.\nNotice how the grey R code chunks are surrounded by 3 back-ticks and {r LABEL}. The first chunk, in this case 1+1, is evaluated and return the output number (2). Notice the line in the second chunk that says #| echo: false? This is a code chunk option that indicates not to print the code. In the rendered version, we can see the outcome of 2*2 but not the executed code that created the outcome.\nThe table below show some of the options available to customizing outputs (Quarto.org).\n\nCode chunk options\n\n\n\n\n\n\nOption\nDescription\n\n\n\n\n#| eval:\nEvaluate the code chunk (if false, just echos the code into the output).\n\n\n#| echo:\nInclude the source code in output\n\n\n#| warning:\nInclude warnings in the output.\n\n\n#| error:\nInclude warnings in the output.\n\n\n#| include:\nCatch all for preventing any output (code or results) from being included (e.g.include: false suppresses all output from the code block).\n\n\n\nNote that you can also combine these options by adding more than one to a code chunk.\n\n\n\n\n\n\nImportant\n\n\n\nOne important difference between Quarto documents and RMarkdown documents is that in Quarto, chunk options are written in special comment format (#|) at the top of code chunks rather than within the wiggly brackets next to ```{r} at the begging of the chunk. For example:\n\nQuarto code options syntax\n\n\n\nRMarkdown code options syntax\n\n\n\n\nIt is important to emphasize one more time that in an Quarto (and RMarkdown) document, the gray areas of the document are code, in this case R code because that is what it is indicated in the ```{r} syntax at the start of this gray area. And the white areas of a qmd are in markdown language."
  },
  {
    "objectID": "session_03.html#markdown-syntax",
    "href": "session_03.html#markdown-syntax",
    "title": "3  Literate Analysis with Quarto",
    "section": "3.5 Markdown Syntax",
    "text": "3.5 Markdown Syntax\nLet’s start by talking about markdown. Markdown is a formatting language for plain text, and there are only around 15 rules to know.\nNotice the syntax in the document we just knitted:\n\nHeaders get rendered at multiple levels: #, ##\nBold: **word**\n\nThere are some good cheatsheets to get you started, and here is one built into RStudio: Go to Help &gt; Markdown Quick Reference.\n\n\n\n\n\n\nImportant\n\n\n\nThe hash symbol # is used differently in markdown and in R\n\nIn an R script or inside an R code chunk, a hash indicates a comment that will not be evaluated. You can use as many as you want: # is equivalent to ######. It’s just a matter of style.\nIn markdown, a hash indicates a level of a header. And the number you use matters: # is a “level one header”, meaning the biggest font and the top of the hierarchy. ### is a level three header, and will show up nested below the # and ## headers.\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\nIn markdown, Write some italic text, make a numbered list, and add a few sub-headers. Use the Markdown Quick Reference (in the menu bar: Help &gt; Markdown Quick Reference).\nRe-knit your html file and observe your edits."
  },
  {
    "objectID": "session_03.html#the-visual-editor",
    "href": "session_03.html#the-visual-editor",
    "title": "3  Literate Analysis with Quarto",
    "section": "3.6 The Visual Editor",
    "text": "3.6 The Visual Editor\nQuarto has a “what you see is what you mean” (WYSIWYM) editor or Visual editor, which can be a nice way to write markdown without remembering all of the markdown rules. Since there aren’t many rules for markdown, we recommend just learning them especially since markdown is used in many, many other contexts besides Quarto and RMarkdown. For example, formatting GitHub comments and README files.\nTo access the editor, click the Visual button in the upper left hand corner of your editor pane. You’ll notice that your document is now formatted as you type, and you can change elements of the formatting using the row of icons in the top of the editor pane. Although we don’t really recommend doing all of your markdown composition in the Visual editor, there are two features to this editor that we believe are immensely helpful, adding citations, and adding tables.\n\n3.6.1 Adding citations\nTo add a citation, go to the visual editor and in the insert drop down, select “Citation.” In the window that appears, there are several options in the left hand panel for the source of your citation. If you have a citation manager, such as Zotero, installed, this would be included in that list. For now, select “From DOI”, and in the search bar enter a DOI of your choice (e.g.: 10.1038/s41467-020-17726-z), then select “Insert.”\n\nAfter selecting insert, a couple of things happen. First, the citation reference is inserted into your markdown text as [@oke2020]. Second, a file called references.bib containing the BibTex format of the citation is created. Third, that file is added to the YAML header of your Quarto document (bibliography: references.bib). Adding another citation will automatically update your references.bib file. So easy!\n\n\n3.6.2 Adding table in markdown\nThe second task that the visual editor is convenient for is generating tables. Markdown tables are a bit finicky and annoying to type, and there are a number of formatting options that are difficult to remember if you don’t use them often. In the top icon bar, the “Table” drop down gives several options for inserting, editing, and formatting tables. Experiment with this menu to insert a small table."
  },
  {
    "objectID": "session_03.html#code-chunks-in-quarto",
    "href": "session_03.html#code-chunks-in-quarto",
    "title": "3  Literate Analysis with Quarto",
    "section": "3.7 Code Chunks in Quarto",
    "text": "3.7 Code Chunks in Quarto\nEvery time when opening a new Quarto document we should start by deleting all template text (everything except for the YAML). Then we save the document into the most convenient folder of our project. Now we are ready to start our work.\nYou can create a new chunk in your Quarto in one of these ways:\n\nGo to Code in the top menu bar, click “Insert Chunk”\nType by hand {r}\nUse the keyboard shortcut\n\nMac:command + option + i\nWindows: Ctrl + Alt + i\n\n\n\n\n\n\n\n\nAbout code chunks\n\n\n\nEach code chunk needs to have an opening syntax ```{r} and a closing syntax ```. Everything in between these lines will be identified as R code.\n\n\nIf I want to write some R code, this is how it would look like.\n\nx &lt;- 4 * 8\n\nhights_ft &lt;- c(5.2, 6.0, 5.7)\n\ncoef &lt;- 3.14\n\nHitting return does not execute this command; remember, it’s just a text file. To execute it, we need to get what we typed in the the R chunk (the grey R code) down into the console. How do we do it? There are several ways (let’s do each of them):\n\nCopy-paste this line into the console (generally not recommended as a primary method)\nSelect the line (or simply put the cursor there), and click “Run”. This is available from:\n\nthe bar above the file (green arrow)\nthe menu bar: Code &gt; Run Selected Line(s)\nkeyboard shortcut: command-return\n\nClick the green arrow at the right of the code chunk"
  },
  {
    "objectID": "session_03.html#practice-literate-analysis-with-ocean-water-samples",
    "href": "session_03.html#practice-literate-analysis-with-ocean-water-samples",
    "title": "3  Literate Analysis with Quarto",
    "section": "3.8 Practice: Literate Analysis with ocean water samples",
    "text": "3.8 Practice: Literate Analysis with ocean water samples\nNow that we have gone over the basics, let’s go a little deeper by building a simple, Quarto document that represents a literate analysis using real data. We are going to work with the seawater chemistry data. We are going to download a file named BGchem2008data.csv from the Arctic Data Center repository. Please follow the steps below to download the data and then upload to your RStudio Server data folder.\n\n\n\n\n\n\nSetup\n\n\n\n\nNavigate to the following dataset: https://doi.org/10.18739/A25T3FZ8X\nDownload the file BGchem2008data.csv\nClick the “Upload” button in your RStudio server file browser.\nIn the dialog box, make sure the destination directory is the data directory in your R project, click “Choose File,” and locate the BGchem2008data.csv file. Press “OK” to upload the file.\nCheck your file was successfully uploaded by navigating into your data folder in the Files pane.\n\n\n\n\n3.8.1 Getting Started\nExperienced R users who have never used Quarto (or RMarkdown) often struggle a bit in the transition to developing analysis in Prose+Code format — which makes sense! It is switching the code paradigm to a new way of thinking.\nRather than starting an R chunk and putting all of your code in that single chunk, below we describe what we think is a better way.\n\nOpen a document and block out the high-level sections you know you’ll need to include using top level headers.\nAdd bullet points for some high level pseudo-code steps you know you’ll need to take.\nStart filling in under each bullet point the code that accomplishes each step. As you write your code, transform your bullet points into prose, and add new bullet points or sections as needed.\n\nFor this mini-analysis, we will have the following sections and code steps:\n\nIntroduction\n\nAbout the data\nSetup\nRead in data\n\nAnalysis\n\nCalculate summary statistics\nCalculate mean Redfield ratio\nPlot Redfield ratio\n\nConclusion\n\n\n\n\n\n\n\nExercise\n\n\n\nUnder “About the data”, write a sentence saying where the data set came from, including a hyperlink ti the data. Also mention when was the data downloaded.\nHint: Navigate to Help &gt; Markdown Quick Reference to look-up the hyperlink syntax.\n\n\n\n\n3.8.2 Read in the data\nNow that we have outlined our document, we can start writing code! To read the data into our environment, we will use a function from the readr package.\nTo use a package in our analysis, we need to first make sure it is installed (you can install a package by running install.package(\"name-of-package\")). Once installed you need to load it into our environment using library(package_name). Even though we have installed it, we haven’t yet told our R session to access it. Because there are so many packages (many with conflicting namespaces) R cannot automatically load every single package you have installed. Instead, you load only the ones you need for a particular analysis. Loading the package is a key part of the reproducible aspect of our literate analysis, so we will include it as an R chunk as part of our Setup.\n\n\n\n\n\n\nBest Practice\n\n\n\nIt is generally good practice to include all of your library() calls in a single, dedicated R chunk near the top of your document. This lets collaborators know what packages they might need to install before they start running your code.\n\n\nThe server should have already installed readr, so add a new R chunk below your Setup header that calls the readr library, and run it. It should look like this:\n\nlibrary(readr)\n\nNow, under “Read data”, add a code chunk that uses the read_csv() function to read in your data file.\n\nbg_chem &lt;- read_csv(\"data/BGchem2008data.csv\")\n\nRows: 70 Columns: 19\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr   (1): Station\ndbl  (16): Latitude, Longitude, Target_Depth, CTD_Depth, CTD_Salinity, CTD_T...\ndttm  (1): Time\ndate  (1): Date\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\nWhy read_csv() over read.csv()?\nWe chose to show read_csv() from the readr package to introduce the concept of packages, to show you how to load packages, and read_csv() has several advantages over read.csv() from base R, including:\n\nMore reasonable function defaults (no stringsAsFactors!)\nSmarter column type parsing, especially for dates\nread_csv() is much faster than read.csv(), which is helpful for large files\n\nOnce you run this line in your document, you should see the bg_chem object populate in your environment pane. It also spits out lots of text explaining what types the function parsed each column into. This text is important, and should be examined, but we might not want it in our final document.\n\n\n\n\n\n\nExercise\n\n\n\nHow would you suppress the warnings (so they don’t show in our output file) form a specific code chunk?\nHint: Code chunk options\n\n\n\n\n3.8.3 Calculate Summary Statistics\nAs our “analysis” we are going to calculate some very simple summary statistics and generate a single plot. Using water samples from the Arctic Ocean, we will examine the ratio of nitrogen to phosphate to see how closely the data match the Redfield ratio, which is the consistent 16:1 ratio of nitrogen to phosphorous atoms found in marine phytoplankton.\nLet’s start by exploring the data we just read. Every time we read a new data set, it is important to familiarize yourself with it and make sure that the data looks as expected. Below some useful functions for exploring your data.\nLet’s start by creating a new R chunk and run the following functions. Because this just an exploration and we do not want this chunk to be part of our report, we will indicate that by adding #|eval: false and #| echo: false in the setup of the chunk, that way, the code in this chunk will not run and not be displayed when I knit the final document.\n\n## Prints the column names of my data frame\ncolnames(bg_chem)\n\n## General structure of the data frame - shows class of each column\nstr(bg_chem)\n\n## First 6 lines of the data frame\nhead(bg_chem)\n\n## Summary of each column of data\nsummary(bg_chem)\n\n## Prints unique values in a column (in this case Date)\nunique(bg_chem$Date)\n\nTo peek out data frame, we can type View(bg_chem) in the console. This will open a tab with our data frame in a tabular format.\nNow that we know a more about the data set we are working with lets do some analyses. Under the appropriate bullet point in your analysis section, create a new R chunk, and use it to calculate the mean nitrate (NO3), nitrite (NO2), ammonium (NH4), and phosphorous (P) measured.\nSave these mean values as new variables with easily understandable names, and write a (brief) description of your operation using markdown above the chunk. Remember that the $ (aka the subset operator) indicates which column of your data to look into.\n\nnitrate &lt;- mean(bg_chem$NO3)\nnitrite &lt;- mean(bg_chem$NO2)\namm &lt;- mean(bg_chem$NH4)\nphos &lt;- mean(bg_chem$P)\n\nIn another chunk, use those variables to calculate the nitrogen: phosphate ratio (Redfield ratio).\n\nratio &lt;- (nitrate + nitrite + amm)/phos\n\nYou can access this variable in your markdown text by using R in-line in your text. The syntax to call R in-line (as opposed to as a chunk) is a single backtick `, followed by the letter “r”, then whatever your simple R command is — here we will use round(ratio) to print the calculated ratio, and finally a closing backtick `. This allows us to access the value stored in this variable in our explanatory text without resorting to the evaluate-copy-paste method so commonly used for this type of task.\nSo, the text in you Quarto document should look like this:\nThe Redfield ratio for this dataset is approximately: `r round(ratio)`\nAnd the rendered text like this:\nThe Redfield ratio for this dataset is approximately 6.\nFinally, create a simple plot using base R that plots the ratio of the individual measurements, as opposed to looking at mean ratio.\n\nplot(bg_chem$P, bg_chem$NO2 + bg_chem$NO3 + bg_chem$NH4)\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nDecide whether or not you want the plotting code above to show up in your knitted document along with the plot, and implement your decision as a chunk option.\nRender your Quarto document (by pressing the Render button) and observe the results.\n\n\n\n\n\n\n\n\nHow do I decide when to make a new code chunk?\n\n\n\nLike many of life’s great questions, there is no clear cut answer. A rule of thumb is to have one chunk per functional unit of analysis. This functional unit could be 50 lines of code or it could be 1 line, but typically it only does one “thing.” This could be reading in data, making a plot, or defining a function. It could also mean calculating a series of related summary statistics (as we’ll see below). Ultimately, the choice is one related to personal preference and style, but generally you should ensure that code is divided up such that it is easily explainable in a literate analysis as the code is run."
  },
  {
    "objectID": "session_03.html#quarto-file-paths-and-environement",
    "href": "session_03.html#quarto-file-paths-and-environement",
    "title": "3  Literate Analysis with Quarto",
    "section": "3.9 Quarto file paths and environement",
    "text": "3.9 Quarto file paths and environement\nAs we discussed during our setup session, in computing, a path specifies the unique location of a file on the filesystem. A path can come in one of two forms: absolute or relative.\n\nAbsolute paths start at the very top of your file system, and work their way down the directory tree to the file.\nRelative paths start at an arbitrary point in the file system. In R, this point is set by your working directory.\n\nQuarto has a special way of handling relative paths that can be very handy. When working in an Quarto document, R will set all paths relative to the location of the Quarto file. This way, you don’t have to worry about setting a working directory, or changing your colleagues absolute path structure with the correct user name, etc. If your Quarto document is stored near where the data it analyses are stored (good practice, generally), setting paths becomes much easier!\nIf you saved your BGchem2008data.csv data file in the same location as your qmd, you can just write read_csv(\"BGchem2008data.csv\") to read it in. Checkout the help page by typing ?read_csv() in the console. This tells you that for this function the first argument should be a pointer to the file. Rstudio has some nice helpers to help you navigate paths. If you open quotes and press tab with your cursor between the quotes, a popup menu will appear showing you some options.\n\n3.9.1 Practice: Quarto and Environments\nLet’s walk through an exercise with the document we just created to demonstrate how Quarto handles environments. We will be deliberately inducing some errors here for demonstration purposes.\nFirst, follow these steps:\n\n\n\n\n\n\nSetup\n\n\n\n\nRestart your R session (Session &gt; Restart R)\nRun the last chunk in your Quarto document by pressing the play button on the chunk\n\n\n\nPerhaps not surprisingly, we get an error:\nError in plot(bg_chem$P, bg_chem$NO2 + bg_chem$NO3 + bg_chem$NH4) : \n  object 'bg_chem' not found\nThis is because we have not run the chunk of code that reads in the bg_chem data. The R part of Quarto works just like a regular R script. You have to execute the code, and the order that you run it in matters. It is relatively easy to get mixed up in a large Quarto document — running chunks out of order, or forgetting to run chunks.\nTo resolve this, follow the next step:\n\n\n\n\n\n\nSetup continued\n\n\n\n\nSelect from the “Run” menu (top right of the editor pane) “Run All.”\nObserve the bg_chem variable in your environment\n\n\n\nThis is a great way to reset and re-run code when things seem to have gone sideways. It is great practice to do periodically since it helps ensure you are writing code that actually runs and it’s reproducible.\n\n\n\n\n\n\nFor the next exercise:\n\n\n\n\nClean your environment by clicking the broom in the environment pane\nRestart your R session (Session &gt; Restart R)\nPress “Render” to run all of the code in your document\nObserve the state of your environment pane\n\nAssuming your document rendered and produced an html page, your code ran. Yet, the environment pane is empty. What happened?\n\n\nThe Render button is rather special — it doesn’t just run all of the code in your document. It actually spins up a fresh R environment separate from the one you have been working in, runs all of the code in your document, generates the output, and then closes the environment. This is one of the best ways Quarto (or RMarkdown) helps ensure you have built a reproducible workflow. If, while you were developing your code, you ran a line in the console as opposed to adding it to your Quarto document, the code you develop while working actively in your environment will still work. However, when you knit your document, the environment RStudio spins up doesn’t know anything about that working environment you were in. Thus, your code may error because it doesn’t have that extra piece of information. Commonly, library() calls are the source of this kind of frustration when the author runs it in the console, but forgets to add it to the script.\nTo further clarify the point on environments, perform the following steps:\n\n\n\n\n\n\nSetup continued\n\n\n\n\nSelect from the “Run” menu (top right of editor pane) “Run All”\nObserve all of the variables in your environment\n\n\n\n\n\n\n\n\n\nWhat about all my R Scripts?\n\n\n\nSome pieces of R code are better suited for R scripts than Quarto or RMarkdown. A function you wrote yourself that you use in many different analyses is probably better to define in an R script than repeated across many Quarto or RMarkdown documents. Some analyses have mundane or repetitive tasks that don’t need to be explained very much. For example, in the document shown in the beginning of this lesson, 15 different excel files needed to be reformatted in slightly different, mundane ways, like renaming columns and removing header text. Instead of including these tasks in the primary Quarto document, the authors chose to write one R script per file and stored them all in a directory. Then, took the contents of one script and included it in the literate analysis, using it as an example to explain what the scripts did, and then used the source() function to run them all from within the Quarto document.\nSo, just because you know Quarto now, doesn’t mean you won’t be using R scripts anymore. Both .R and .qmd have their roles to play in analysis. With practice, it will become more clear what works well in Quarto or RMarkdown, and what belongs in a regular R script."
  },
  {
    "objectID": "session_03.html#additional-quarto-resources",
    "href": "session_03.html#additional-quarto-resources",
    "title": "3  Literate Analysis with Quarto",
    "section": "3.10 Additional Quarto Resources",
    "text": "3.10 Additional Quarto Resources\n\nPosit (the organization that developed Quarto) has great documentation, check out Quarto.org\nR for Data Science (2e) (Wickham et al, 2023), this is an awesome book for all R related things. Chapter 29 and 30 are specific to Quarto.\nQuarto Gallery: Example of different outputs created using Quarto\nHello Quarto: share, collaborate, teach, reimagine. A talk by Julia Stewart Lowndes and Mine Cetinkaya-Runde."
  },
  {
    "objectID": "session_03.html#troubleshooting-my-rmarkdown-wont-knit-to-pdf",
    "href": "session_03.html#troubleshooting-my-rmarkdown-wont-knit-to-pdf",
    "title": "3  Literate Analysis with Quarto",
    "section": "3.11 Troubleshooting: My RMarkdown Won’t Knit to PDF",
    "text": "3.11 Troubleshooting: My RMarkdown Won’t Knit to PDF\nIf you get an error when trying to knit to PDF that says your computer doesn’t have a LaTeX installation, one of two things is likely happening:\n\nYour computer doesn’t have LaTeX installed\nYou have an installation of LaTeX but RStudio cannot find it (it is not on the path)\n\nIf you already use LaTeX (like to write papers), you fall in the second category. Solving this requires directing RStudio to your installation - and isn’t covered here.\nIf you fall in the first category - you are sure you don’t have LaTeX installed - can use the R package tinytex to easily get an installation recognized by RStudio, as long as you have administrative rights to your computer.\nTo install tinytex run:\n\ninstall.packages(\"tinytex\")\ntinytex::install_tinytex()\n\nIf you get an error that looks like destination /usr/local/bin not writable, you need to give yourself permission to write to this directory (again, only possible if you have administrative rights). To do this, run this command in the terminal:\nsudo chown -R `whoami`:admin /usr/local/bin\nand then try the above install instructions again. Learn more about tinytex from Yihui Xie’s online book TinyTeX. ````"
  },
  {
    "objectID": "session_04.html#reproducibility-activity-using-lego",
    "href": "session_04.html#reproducibility-activity-using-lego",
    "title": "4  LEGO® Reproducibility Activity",
    "section": "4.1 Reproducibility activity using LEGO®",
    "text": "4.1 Reproducibility activity using LEGO®\n\nLearning Objectives\n\nIllustrate elements of good reproducibility through the medium of LEGO®\nDiscuss what is needed and what is not needed for good reproducibility\n\n\n\n\n\n\n\nAcknowledgements\n\n\n\nThis activity is largely based on the LEGO® Metadata for Reproducibility game pack, which was developed by Mary Donaldson and Matt Mahon."
  },
  {
    "objectID": "session_04.html#getting-started",
    "href": "session_04.html#getting-started",
    "title": "4  LEGO® Reproducibility Activity",
    "section": "4.2 Getting started",
    "text": "4.2 Getting started\n\n\n\n\n\n\nSetup\n\n\n\n\nGather into small groups\nGet LEGO® blocks and worksheets (instructions + metadata documentation)\nFollow directions on worksheets\n\n\n\nAt the end, we will discuss as a group."
  },
  {
    "objectID": "session_04.html#discussion",
    "href": "session_04.html#discussion",
    "title": "4  LEGO® Reproducibility Activity",
    "section": "4.3 Discussion",
    "text": "4.3 Discussion\n\n\nDiscussion Questions\n\n\nDid you find this a simple way to document your process?\nWas there anything you found difficult to capture?\nDid those replicating the builds find it straightforward to follow?\nDid you encounter any ambiguity in the instructions?"
  },
  {
    "objectID": "session_05.html#learning-objectives",
    "href": "session_05.html#learning-objectives",
    "title": "5  Data Management Lens for Publishing and Accesing Data",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nUnderstand the importance of data management for successfully preserving data\nLearn about metadata guidelines and best practices for reproducibility\nBecome familiar with environmental data repositories for accessing and publishing data"
  },
  {
    "objectID": "session_05.html#the-big-idea",
    "href": "session_05.html#the-big-idea",
    "title": "5  Data Management Lens for Publishing and Accesing Data",
    "section": "5.1 The Big Idea",
    "text": "5.1 The Big Idea\nThe ultimate goal of this lesson is to provide an overview of a reproducible open science framework for your research, when either you are accessing published data (data user) to – for example use it for synthesis or you want to publish your own data (data author). To achieve this, we are going to talk about the following topics.\n\nThe Data Life Cycle\nThe importance of data management\nMetadata best practices\nData preservation\n\nWe will discuss how these topics relate to each other and why they are the building block for you to use others’ data and for others to access, interpret, and use your data in the future."
  },
  {
    "objectID": "session_05.html#the-data-life-cycle",
    "href": "session_05.html#the-data-life-cycle",
    "title": "5  Data Management Lens for Publishing and Accesing Data",
    "section": "5.2 The Data Life Cycle",
    "text": "5.2 The Data Life Cycle\nThe Data Life Cycle gives you an overview of meaningful steps in a research project. This step-by-step breakdown facilitates successful management and preservation of data throughout a project. Some research activities might use only part of the life cycle. For example, a meta-analysis might focus on the Discover, Integrate, and Analyze steps, while a project focused on primary data collection and analysis might bypass the Discover and Integrate steps.\n\n\n\nSource: DataOne\n\n\nThe first step to working with data is identifying where my project is starting in the Data Life Cycle. Using the data life cycle stages, create your own cycle that best fits your project needs.\nA way to use the Data Life Cycle in practice is to:\n\nThink about the end goal, outcomes, and products of your project\nThink and decide steps in the Data Life Cycle you need to include in your project\nReview best practices for that step in the cycle and start outlining action items in each of those steps.\n\nDataOne’s Data Management Skillbuilding Hub offers several best practices on how to effectively work with your data throughout all stages of the data life cycle.\nNo matter how your data life cycle looks like, Plan should be at the top of the cycle. It is advisable to initiate your data management planning at the beginning of your research process before any data has been collected or discovered. The following section will discuss more in-depth data management and how to plan accordingly"
  },
  {
    "objectID": "session_05.html#managing-your-data",
    "href": "session_05.html#managing-your-data",
    "title": "5  Data Management Lens for Publishing and Accesing Data",
    "section": "5.3 Managing your data",
    "text": "5.3 Managing your data\nSuccessfully managing your data throughout a research project helps ensures its preservation for future use.\n\n5.3.1 Why manage your data?\nFrom a Researcher Perspective\n\nKeep yourself organized – be able to find your files (data inputs, analytic scripts, outputs at various stages of the analytic process, etc.)\nTrack your science processes for reproducibility – be able to match up your outputs with exact inputs and transformations that produced them\nBetter control versions of data – easily identify versions that can be periodically purged\nQuality control your data more efficiently\nTo avoid data loss (e.g. making backups)\nFormat your data for re-use (by yourself or others)\nBe prepared: Document your data for your own recollection, accountability, and re-use (by yourself or others)\nGain credibility and recognition for your science efforts through data sharing!\n\nAdvancement of Science\n\nData is a valuable asset – it is expensive and time consuming to collect\nMaximize the effective use and value of data and information assets\nContinually improve the quality including: data accuracy, integrity, integration, timeliness of data capture and presentation, relevance, and usefulness\nEnsure appropriate use of data and information\nFacilitate data sharing\nEnsure sustainability and accessibility in long term for re-use in science\n\n\n\n5.3.2 Tools to Manage your Data\nA Data Management Plan (DMP) is a document that describes how you will use your data during a research project, as well as what you will do with your data long after the project ends. DMPs are living documents and should be updated as research plans change to ensure new data management practices are captured (Environmental Data Initiative).\nA well-thought-out plan means you are more likely to:\n\nstay organized\nwork efficiently\ntruly share data\nengage your team\nmeet funder requirements as DMPs are becoming common in the submission process for proposals\n\nA DMP is both a straightforward blueprint for how you manage your data, and provides guidelines for your and your team on policies, access, roles, and more. While it is important to plan, it is equally important to recognize that no plan is perfect as change is inevitable. To make your DMP as robust as possible, treat it as a “living document” that you periodically review with your team and adjust as the needs of the project change.\n\n\n5.3.3 How to Plan\n\nPlan early: research shows that over time, information is lost and this is inevitable so it’s important to think about long-term plans for your research at the beginning before you’re deep in your project. And ultimately, you’ll save more time.\nPlan in collaboration: high engagement of your team and other important contributors is not only a benefit to your project, but it also makes your DMP more resilient. When you include diverse expertise and perspectives to the planning stages, you’re more likely to overcome obstacles in the future.\nUtilize existing resources: don’t reinvent the wheel! There are many great DMP resources out there. Consider the article Ten Simple Rules for Creating a Good Data Management Plan (Michener 2015), which has succinct guidelines on what to include in a DMP. Or use an online tool like DMPTool, which provides official DMP templates from funders like NSF, example answers, and allows for collaboration.\nMake revising part of the process: Don’t let your DMP collect dust after your initially write it. Make revising the DMP part of your research project and use it as a guide to ensure you’re keeping on track.\nInclude tidy and ethical lens: It is important to start thinking through these lenses during the planning process of your DMP, it will make it easier to include and maintain tidy and ethical principles throughout the entire project. We will discuss in depth about tidy data, FAIR principles and data ethics though the CARE principles later this week.\n\nMore details on what to include in a Data Management Plan in Additional Resources"
  },
  {
    "objectID": "session_05.html#metadata-best-practices",
    "href": "session_05.html#metadata-best-practices",
    "title": "5  Data Management Lens for Publishing and Accesing Data",
    "section": "5.4 Metadata Best Practices",
    "text": "5.4 Metadata Best Practices\nWithin the data life cycle you can be collecting data (creating new data) or integrating data that has all ready been collected. Either way, metadata plays plays a major role to successfully spin around the cycle because it enables data reuse long after the original collection.\nImagine that you’re writing your metadata for a typical researcher (who might even be you!) 30+ years from now - what will they need to understand what’s inside your data files?\nThe goal is to have enough information for the researcher to understand the data, interpret the data, and then reuse the data in another study.\n\n5.4.1 Overall Guidelines\nAnother way to think about metadata is to answer the following questions with the documentation:\n\nWhat was measured?\nWho measured it?\nWhen was it measured?\nWhere was it measured?\nHow was it measured?\nHow is the data structured?\nWhy was the data collected?\nWho should get credit for this data (researcher AND funding agency)?\nHow can this data be reused (licensing)?\n\n\n\n5.4.2 Bibliographic Guidelines\nThe details that will help your data be cited correctly are:\n\nGlobal identifier like a digital object identifier (DOI)\nDescriptive title that includes information about the topic, the geographic location, the dates, and if applicable, the scale of the data\nDescriptive abstract that serves as a brief overview off the specific contents and purpose of the data package\nFunding information like the award number and the sponsor\nPeople and organizations like the creator of the dataset (i.e. who should be cited), the person to contact about the dataset (if different than the creator), and the contributors to the dataset\n\n\n\n5.4.3 Discovery Guidelines\nThe details that will help your data be discovered correctly are:\n\nGeospatial coverage of the data, including the field and laboratory sampling locations, place names and precise coordinates\nTemporal coverage of the data, including when the measurements were made and what time period (ie the calendar time or the geologic time) the measurements apply to\nTaxonomic coverage of the data, including what species were measured and what taxonomy standards and procedures were followed\nAny other contextual information as needed\n\n\n\n5.4.4 Interpretation Guidelines\nThe details that will help your data be interpreted correctly are:\n\nCollection methods for both field and laboratory data the full experimental and project design as well as how the data in the dataset fits into the overall project\nProcessing methods for both field and laboratory samples\nAll sample quality control procedures\nProvenance information to support your analysis and modelling methods\nInformation about the hardware and software used to process your data, including the make, model, and version\nComputing quality control procedures like testing or code review\n\n\n\n5.4.5 Data Structure and Contents\n\nEverything needs a description: the data model, the data objects (like tables, images, matrices, spatial layers, etc), and the variables all need to be described so that there is no room for misinterpretation.\nVariable information includes the definition of a variable, a standardized unit of measurement, definitions of any coded values (i.e. 0 = not collected), and any missing values (i.e. 999 = NA).\n\nNot only is this information helpful to you and any other researcher in the future using your data, but it is also helpful to search engines. The semantics of your dataset are crucial to ensure your data is both discoverable by others and interoperable (that is, reusable).\nFor example, if you were to search for the character string “carbon dioxide flux” in a data repository, not all relevant results will be shown due to varying vocabulary conventions (i.e., “CO2 flux” instead of “carbon dioxide flux”) across disciplines — only datasets containing the exact words “carbon dioxide flux” are returned. With correct semantic annotation of the variables, your dataset that includes information about carbon dioxide flux but that calls it CO2 flux WOULD be included in that search.\n\n\n5.4.6 Rights and Attribution\nCorrectly assigning a way for your datasets to be cited and reused is the last piece of a complete metadata document. This section sets the scientific rights and expectations for the future on your data, like:\n\nCitation format to be used when giving credit for the data\nAttribution expectations for the dataset\nReuse rights, which describe who may use the data and for what purpose\nRedistribution rights, which describe who may copy and redistribute the metadata and the data\nLegal terms and conditions like how the data are licensed for reuse.\n\n\n\n5.4.7 Metadata Standards\nSo, how does a computer organize all this information? There are a number of metadata standards that make your metadata machine readable and therefore easier for data curators to publish your data.\n\nEcological Metadata Language (EML)\nGeospatial Metadata Standards (ISO 19115 and ISO 19139)\n\nSee NOAA’s ISO Workbook\n\nBiological Data Profile (BDP)\nDublin Core\nDarwin Core\nPREservation Metadata: Implementation Strategies (PREMIS)\nMetadata Encoding Transmission Standard (METS)\n\nNote this is not an exhaustive list.\n\n\n5.4.8 Data Identifiers\nMany journals require a DOI (a digital object identifier) be assigned to the published data before the paper can be accepted for publication. The reason for that is so that the data can easily be found and easily linked to.\nSome data repositories assign a DOI for each dataset you publish on their repository. But, if you need to update the datasets, check the policy of the data repository. Some repositories assign a new DOI after you update the dataset. If this is the case, researchers should cite the exact version of the dataset that they used in their analysis, even if there is a newer version of the dataset available.\n\n\n5.4.9 Data Citation\nResearchers should get in the habit of citing the data that they use (even if it’s their own data!) in each publication that uses that data."
  },
  {
    "objectID": "session_05.html#data-sharing-preservation",
    "href": "session_05.html#data-sharing-preservation",
    "title": "5  Data Management Lens for Publishing and Accesing Data",
    "section": "5.5 Data Sharing & Preservation",
    "text": "5.5 Data Sharing & Preservation\n\n\n5.5.1 Data Packages\n\nWe define a data package as a scientifically useful collection of data and metadata that a researcher wants to preserve.\n\nSometimes a data package represents all of the data from a particular experiment, while at other times it might be all of the data from a grant, or on a topic, or associated with a paper. Whatever the extent, we define a data package as having one or more data files, software files, and other scientific products such as graphs and images, all tied together with a descriptive metadata document.\nMany data repositories assign a unique identifier to every version of every data file, similarly to how it works with source code commits in GitHub. Those identifiers usually take one of two forms. A DOI identifier, often assigned to the metadata and becomes a publicly citable identifier for the package. Each of the other files gets a global identifier, often a UUID that is globally unique. This allows to identify a digital entity within a data package.\nIn the graphic to the side, the package can be cited with the DOI doi:10.5063/F1Z1899CZ,and each of the individual files have their own identifiers as well.\n\n\n\n5.5.2 Data Repositories: Built for Data (and code)\n\nGitHub is not an archival location\nExamples of dedicated data repositories:\n\nKNB\nArctic Data Center\ntDAR\nEDI\nZenodo\n\nDedicated data repositories are:\n\nRich in metadata\nArchival in their mission\nCertified\n\nData papers, e.g., Scientific Data\nre3data is a global registry of research data repositories\nRepository Finder is a pilot project and tool to help researchers find an appropriate repository for their work\n\n\n5.5.2.1 DataOne Federation\nDataONE is a federation of dozens of data repositories that work together to make their systems interoperable and to provide a single unified search system that spans the repositories. DataONE aims to make it simpler for researchers to publish data to one of its member repositories, and then to discover and download that data for reuse in synthetic analyses.\nDataONE can be searched on the web, which effectively allows a single search to find data from the dozens of members of DataONE, rather than visiting each of the (currently 44!) repositories one at a time."
  },
  {
    "objectID": "session_05.html#summary",
    "href": "session_05.html#summary",
    "title": "5  Data Management Lens for Publishing and Accesing Data",
    "section": "5.6 Summary",
    "text": "5.6 Summary\n\nThe Data Life Cycle help us see the big picture of our data project.\nOnce we identify the necessary steps it is helpful to think through each one and plan accordingly.\nIt is extremely helpful to develop a data management plan is to stay organized.\nDocument everything. Having rich metadata is a key factor to enable data reuse. Describe your data and files and use an appropriate metadata standard.\nPublish your data in a stable long live repository and assign a unique identifier."
  },
  {
    "objectID": "session_05.html#data-users-example",
    "href": "session_05.html#data-users-example",
    "title": "5  Data Management Lens for Publishing and Accesing Data",
    "section": "5.7 Data Users Example",
    "text": "5.7 Data Users Example\nData Life Cycle\n\nPlan\nDiscover: Finding and understanding data\nIntegrate: Accessing Data\nAnalyze\nDescribe: Metadata, Citing data (provenance)\nPreserve: Publishing a derived data package"
  },
  {
    "objectID": "session_05.html#exercise-evaluate-a-data-package-on-the-edi-repository",
    "href": "session_05.html#exercise-evaluate-a-data-package-on-the-edi-repository",
    "title": "5  Data Management Lens for Publishing and Accesing Data",
    "section": "5.8 Exercise: Evaluate a Data Package on the EDI Repository",
    "text": "5.8 Exercise: Evaluate a Data Package on the EDI Repository\nExplore data packages published on EDI assess the quality of their metadata. Imagine you are planning on using this data for a synthesis project.\n\n\n\n\n\n\nSetup\n\n\n\nBreak into groups and use the following data packages:\n\nGroup A: SBC LTER: Reef: Abundance, size and fishing effort for California Spiny Lobster (Panulirus interruptus), ongoing since 2012\nGroup B: Physiological stress of American pika (Ochotona princeps) and associated habitat characteristics for Niwot Ridge, 2018 - 2019\nGroup C: Ecological and social interactions in urban parks: bird surveys in local parks in the central Arizona-Phoenix metropolitan area\nGroup D: Interagency Ecological Program: Fish catch and water quality data from the Sacramento River floodplain and tidal slough, collected by the Yolo Bypass Fish Monitoring Program, 1998-2021.\n\n\n\n\nYou and your group will evaluate a data package for its: (1) metadata quality, and (2) data documentation quality for reusability.\n\n\n\n\n\n\nExercise: Evaluate a data package\n\n\n\n\nOpen our Data Package Assessment Rubric (Note: Evaluate only the Metadata Documentation and Quality section), make copy and:\n\nInvestigate the metadata in the provided data\n\nDoes the metadata meet the standards we talked about? How so?\nIf not, how would you improve the metadata based on the standards we talked about?\n\nInvestigate the overall data documentation in the data package\n\nIs the documentation sufficient enough for reusing the data? Why or why not?\nIf not, how would you improve the data documentation? What’s missing?\n\n\nElect someone to share back to the group the following:\n\nHow easy or challenging was it to find the metadata and other data documentation you were evaluating? Why or why not?\nWhat documentation stood out to you? What did you like or not like about it?\nDo you feel like you understand the research project enough to use the data yourself (aka reproducibility?\n\n\nIf you and your group finish early, check out more datasets in the bonus question."
  },
  {
    "objectID": "session_05.html#bonus-investigate-metadata-and-data-documentation-in-other-data-repositories",
    "href": "session_05.html#bonus-investigate-metadata-and-data-documentation-in-other-data-repositories",
    "title": "5  Data Management Lens for Publishing and Accesing Data",
    "section": "5.9 Bonus: Investigate metadata and data documentation in other Data Repositories",
    "text": "5.9 Bonus: Investigate metadata and data documentation in other Data Repositories\nNot all environmental data repositories document and publish datasets and data packages in the same way. Nor do they have the same submission requirements. It’s helpful to become familiar with metadata and data documentation jargon so it’s easier to identify the information you’re looking for. It’s also helpful for when you’re nearing the end of your project and are getting ready to publish your datasets.\nEvaluate the following data packages at these data repositories:\n\nKNB Arthropod pitfall trap biomass captured (weekly) and pitfall biomass model predictions (daily) near Toolik Field Station, Alaska, summers 2012-2016\nDataOne USDA-NOAA NWS Daily Climatological Data\nArctic Data Center Landscape evolution and adapting to change in ice-rich permafrost systems 2021-2022\n\nHow different are these data repositories from the EDI Data Portal? Would you consider publishing you data at one or multiple of these repositories?"
  },
  {
    "objectID": "session_05.html#additional-resouces",
    "href": "session_05.html#additional-resouces",
    "title": "5  Data Management Lens for Publishing and Accesing Data",
    "section": "5.10 Additional Resouces",
    "text": "5.10 Additional Resouces\n\n5.10.1 What to include in a DMP\n\n\n\n\n\n\n\nDMP Section\nGuiding Questions\n\n\n\n\nFunder Requirements\n\nDoes the funder have a template or specific DMP guidelines?\nDo you thoroughly understand all the requirements? Or do you need to reach out for clarification?\nIs there a page-limit to what you can submit in your proposal? Would it beneficial to have an appendix or a longer version of your DMP for internal use elsewhere (and not for submission)?\n\n\n\nStudy Design\n\nWhat analytical methods do you plan to use?\nWhat experiments, if any, are needed to answer your research question?\nWhat are the end products you plan to produce?\nWhat ethical considerations do you have about your project?\n\n\n\nData Collection\n\nWhat type of data do you plan to collect (text, audio files, images, models, spreadsheets)?\nWhere do you plan to source your data? Is it observational, already existing, or does it need to be collected? Do you need to obtain a license to access the data? Do you need an IRB review?\nHow much data do you plan to collect or use?\nWhat format is the data in? Is it open source or is it proprietary?\n\n\n\nData Organization\n\nHow will you manage your data? Will you be using open source or proprietary software programs?\nDo you need a database to manage your data? Are there existing databases you can utilize or do you need to build one?\nWhat software tools do you plan to use to manage and organize your data?\n\n\n\nQuality Assurance and Quality Control\n\nHow will you ensure that your data is of quality?\nHow will you maintain data integrity throughout your analysis?\nWhat tests will you run on your raw data and processed data?\nWill you be utilizing outside partners to implement testing or QA/QC measures?\n\n\n\nData Policies\n\nWhat licenses do you plan to use for your data? Are there open source licenses that meet your funders requirements?\nWhat are the policies for sharing, retaining, and licensing the data? Whose responsibility is that?\nAre there any legal or ethical restrictions on your data? Do you have sensitive data that cannot be shared? Is a metadata documentation appropriate?\n\n\n\nData documentation & Metadata\n\nWhat information is required for you and others to accurately interpret, reuse, and access your data?\nWill you be using a metadata standard?\nWhat information is needed for you to write comprehensive metadata?\nWhere and how will you maintain this documentation? Is it possible for you to have the documentation open source?\n\n\n\nData Sharing\n\nHow will the data be shared after the project ends? Is this an accessible location?\nWhen will the data and project be available? Immediately after the project ends or a time period after?\nWill you be publishing the project and the data to a journal?\nWhat data products do you plan to share?\n\n\n\nRoles and Responsibilities\n\nWho is in charge of collecting the data? Managing it? Storing it? Archiving it? Running quality control? Overall project management? There are lots of roles to consider here.\nWhat kind of expertise is needed for these roles?\nWhat happens if a role needs to change? How do you plan to handle this kind of change?\n\n\n\nLong-term Storage & Data Preservation\n\nWhere do you plan to archive your data?\nHow long will the data be accessible?\nHow will the data be accessed for future use?\nHow will you be storing the data during your project? Is this different than where you will store it after the project ends?\nDoes your institution or funder have long-term storage options for you to use?\n\n\n\nBudget\n\nDo you need to purchase any proprietary software?\nDo you need to purchase any hardware?\nDo you need to pay for any services?\nWill you need to hire employees? Consultants?\nDo you anticipate that you will need to pay for any professional development or training either for yourself or your team?\n\n\n\n\n\n\n\n\nMichener, William K. 2015. “Ten Simple Rules for Creating a Good Data Management Plan.” PLOS Computational Biology 11 (10): 1–9. https://doi.org/10.1371/journal.pcbi.1004525."
  },
  {
    "objectID": "session_06.html#learning-objectives",
    "href": "session_06.html#learning-objectives",
    "title": "6  Logic Model",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nProvide an overview of Logic Models\nApply the principles of Logic Models to synthesis development\nRefine synthesis group challenges"
  },
  {
    "objectID": "session_06.html#logic-models",
    "href": "session_06.html#logic-models",
    "title": "6  Logic Model",
    "section": "6.1 Logic Models",
    "text": "6.1 Logic Models\nLogic models are a planning tool that are designed to support program development by depicting the flow of resources and processes leading to a desired result. They are also used for outcomes-based evaluation of a program and are often requested as part of an evaluation planning process by funders or stakeholders.\nA simplified logic models comprise three main parts: Inputs, Outputs and Outcomes.\n\nInputs reflect what is invested, outputs are what is done and outcomes are the results of the program.\nIn a more detailed logic model, outputs and outcomes are further broken down. Outputs are often represented as ‘Activities’ and ‘Participants’. By including participation (or participants), the logic model is explicitly considering the intended audience, or stakeholders, impacted by the program. Engagement of this audience is an output. In the case of outcomes, these can be split into short, medium and long-term outcomes. Sometimes this last category may be labeled ‘Impact’\n\nDefining the inputs, outputs and outcomes early in a planning process enables teams to visualize the workflow from activity to results and can help mitigate potential challenges. Logic models can be thought of as having an ‘if this then that’ structure where inputs -&gt; outputs -&gt; outcomes.\n\nIn the example below we have constructed a simple logic model for a hypothetical project where training materials are being developed for a group of educators to implement at their respective institutions.\n\nLinkages are not always sequential and can be within categories, bi-directional and/or include feedback loops. Detailing this complexity of relationships, or theory of action, can be time consuming but is a valuable part of the thought process for project planning. In exploring all relationships, logic modeling also allows for assessing program feasibility.\n\nThe above graphics include two sections within Outputs - Activities and Participants - and this is quite common. There is variation in logic model templates, including versions with a third type of output - “Products’. Sometimes description of these products is contained within the Activities section - for example, ‘develop curricula’, ‘produce a report’ - however calling these out explicitly is beneficial for teams focused on product development.\nProgram development (and logic modeling) occurs in response to a given ‘Situation’ or need, and exploring this is the first step in modeling. The situation defines the objective, or problem, that the program is designed to solve hence some logic models may omit the left-hand situation column but be framed with Problem and Solution statements. Finally, comprehensive logic modeling takes into consideration assumptions that are made with respect to the resources available, the people involved, or the way the program will work and also recognizes that there are external factors that can impact the program’s success.\n\nIn summary:\nLogic models support program development and evaluation and comprise three primary steps in the workflow:\n\nInputs: Resources, contributions, and investments required for a program;\nOutputs: Activities conducted, participants reached, and products produced; and\nOutcomes: Results or expected changes arising from the program structured as short-, medium- and long-term."
  },
  {
    "objectID": "session_06.html#logic-models-for-synthesis-development",
    "href": "session_06.html#logic-models-for-synthesis-development",
    "title": "6  Logic Model",
    "section": "6.2 Logic models for synthesis development",
    "text": "6.2 Logic models for synthesis development\nLogic models are one tool for program development and have sufficient flexibility for a variety of situations, including planning for a research collaboration. While some logic model categories may feel less relevant (can we scale up to a long-term outcome from a published synthesis?), the process of articulating the research objective, proposed outcome, associated resources and activities has value. Below are examples of questions that a typical logic model (LM) will ask, and how these might be reframed for a research collaboration (RC).\nObjective/Problem Statement\nLM: What is the problem? Why is this a problem? Who does this impact?\nRC: What is the current state of knowledge? What gaps exists in understanding? Why is more information / synthesis important?\nInputs\nLM: What resources are needed for the program? Personnel, money, time, equipment, partnerships ..\nRC: What is needed to undertake the synthesis research? For personnel, think in terms of the roles that are needed - data manager, statistician, writer, editor etc. Consider the time frame. DATA - what data are needed and what already exists?\nOutputs - Activities\nLM: What will be done? Development, design, workshops, conferences, counseling, outreach..\nRC: What activities are needed to conduct the research? This could be high level or it could be broken down into details such as the types of statistical approaches.\nOutputs - Participants\nLM: Who will we reach? Clients, Participants, Customers..\nRC: Who is the target audience? Who will be impacted by this work? Who is positioned to leverage this work?\nOutputs - Products\nLM: What will you create? Publications, websites, media communications …\nRC: What research products are planned / expected? Consider this in relation to the intended audience. Is a peer-reviewed publication, report or white paper most appropriate? How will derived data be handled? Will documentation, workflows, or code be published?\nShort-term Outcomes\nLM: What short-term outcomes are anticipated among participants. These can include changes in awareness, knowledge, skills, attitudes, opinions and intent.\nRC: Will this work represent a significant contribution to current understanding?\nMedium-term Outcomes\nLM: What medium-term outcomes are predicted among participants? These might include changes in behaviors, decision-making and actions.\nRC: Will this work promote increased research activity or open new avenues of inquiry?\nLong-term Outcomes\nLM: What long-term benefits, or impacts, are expected? Changes in social, economic, civic, and environmental conditions?\nRC: Will this work result in local, regional or national policy change? What will be the long-term impact of increased investment in the ecosystem?\n\n\n\n\n\n\nBreakout: Synthesis planning with logic models\n\n\n\nBreakout groups will focus on refining ideas for synthesis topcis using the logic modeling tools described in this section. The goal for this session is to develop one or more high-level logic models that:\n\nSummarize the synthesis challenge\nDefine the inputs needed to approach the synthesis\nDefine the outputs, including activities and products that would would be needed to address the issue\nDefine the short term outcomes and longer-term impacts of the work\n\nOften it is helpful to start with a brainstorming activity to list activities and products that might be used to address the synthesis challenge, then connect those in terms of outcomes and impacts, and then circle back to the resource and data inputs needed to feed the logic model. Thinking of the whole model as a workflow can help conceptualize the dependencies among steps.\nTools:\n\nPowerpoint logic model template\nMermaid flowcharts embedded in Quarto documents\n\n\n\n\n\nflowchart LR\n    INPUTS --&gt; ACTIVITIES --&gt; OUTPUTS --&gt; OUTCOMES/IMPACTS\n\n    Scenario{{Accelerate synthesis via data science training}}\n\n    R1[Instructor] & R2[Classroom space] & R3[Projector] --&gt; B{Data Science Workshop}\n    B --&gt; C(Workshop Curriculum)\n    B --&gt; D(Presentations and Practice)\n    \n    C & D --&gt; E[/Improved Delta management/] & F[/Increased analytic efficiency/]\n\n\n\n\n\nSource\n```{mermaid}\nflowchart LR\n    INPUTS --&gt; ACTIVITIES --&gt; OUTPUTS --&gt; OUTCOMES/IMPACTS\n\n    Scenario{{Accelerate synthesis via data science training}}\n\n    R1[Instructor] & R2[Classroom space] & R3[Projector] --&gt; B{Data Science Workshop}\n    B --&gt; C(Workshop Curriculum)\n    B --&gt; D(Presentations and Practice)\n    \n    C & D --&gt; E[/Improved Delta management/] & F[/Increased analytic efficiency/]\n```"
  },
  {
    "objectID": "session_06.html#resources",
    "href": "session_06.html#resources",
    "title": "6  Logic Model",
    "section": "6.3 Resources",
    "text": "6.3 Resources\n\nLogic model template (ppt) on Sharepoint\n\nSame Logic model template on Google Drive"
  },
  {
    "objectID": "session_07.html#learning-objectives",
    "href": "session_07.html#learning-objectives",
    "title": "7  Introduction to Git and GitHub",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nApply the principles of Git to track and manage changes of a project\nUtilize the Git workflow including pulling changes, staging modified files, committing changes, pulling again to incorporate remote changes, and pushing changes to a remote repository\nCreate and configure Git repositories using different workflows"
  },
  {
    "objectID": "session_07.html#introduction-to-version-control",
    "href": "session_07.html#introduction-to-version-control",
    "title": "7  Introduction to Git and GitHub",
    "section": "7.1 Introduction to Version Control",
    "text": "7.1 Introduction to Version Control\n\n\n\n\n\nEvery file in the scientific process changes. Manuscripts are edited. Figures get revised. Code gets fixed when bugs are discovered. Sometimes those fixes lead to even more bugs, leading to more changes in the codebase. Data files get combined together. Sometimes those same files are split and combined again. All that to say - in just one research project, we can expect thousands of changes to occur.\nThese changes are important to track, and yet, we often use simplistic filenames to track them. Many of us have experienced renaming a document or script multiple times with the ingenuine addition of “final” to the filename (like the comic above demonstrates).\nYou might think there is a better way, and you’d be right: version control. Version control provides an organized and transparent way to track changes in code and additional files. This practice was designed for software development, but is easily applicable to scientific programming.\nThere are many benefits to using a version control software including:\n\nMaintain a history of your research project’s development while keeping your workspace clean\nFacilitate collaboration and transparency when working on teams\nExplore bugs or new features without disrupting your team members’ work\nand more!\n\nThe version control system we’ll be diving into is Git, the most widely used modern version control system in the world."
  },
  {
    "objectID": "session_07.html#introduction-to-git-github",
    "href": "session_07.html#introduction-to-git-github",
    "title": "7  Introduction to Git and GitHub",
    "section": "7.2 Introduction to Git + GitHub",
    "text": "7.2 Introduction to Git + GitHub\nBefore diving into the details of Git and how to use it, let’s start with a motivating example that’s representative of the types of problems Git can help us solve.\n\n7.2.1 A Motivating Example\nSay, for example, you’re working on an analysis in R and you’ve got it into a state you’re pretty happy with. We’ll call this version 1:\n\n\n\nYou come into the office the following day and you have an email from your boss, “Hey, you know what this model needs?”\n\n\n\nYou’re not entirely sure what she means but you figure there’s only one thing she could be talking about: more cowbell. So you add it to the model in order to really explore the space.\nBut you’re worried about losing track of the old model so, instead of editing the code in place, you comment out the old code and put as serious a warning as you can muster in a comment above it.\n\n\n\nCommenting out code you don’t want to lose is something probably all of us have done at one point or another but it’s really hard to understand why you did this when you come back years later or you when you send your script to a colleague. Luckily, there’s a better way: Version control. Instead of commenting out the old code, we can change the code in place and tell Git to commit our change. So now we have two distinct versions of our analysis and we can always see what the previous version(s) look like.\n\n\n\nYou may have noticed something else in the diagram above: Not only can we save a new version of our analysis, we can also write as much text as we like about the change in the commit message. In addition to the commit message, Git also tracks who, when, and where the change was made.\nImagine that some time has gone by and you’ve committed a third version of your analysis, version 3, and a colleague emails with an idea: What if you used machine learning instead?\n\n\n\nMaybe you’re not so sure the idea will work out and this is where a tool like Git shines. Without a tool like Git, we might copy analysis.R to another file called analysis-ml.R which might end up having mostly the same code except for a few lines. This isn’t particularly problematic until you want to make a change to a bit of shared code and now you have to make changes in two files, if you even remember to.\nInstead, with Git, we can start a branch. Branches allow us to confidently experiment on our code, all while leaving the old code in tact and recoverable.\n\n\n\nSo you’ve been working in a branch and have made a few commits on it and your boss emails again asking you to update the model in some way. If you weren’t using a tool like Git, you might panic at this point because you’ve rewritten much of your analysis to use a different method but your boss wants change to the old method.\n\n\n\nBut with Git and branches, we can continue developing our main analysis at the same time as we are working on any experimental branches. Branches are great for experiments but also great for organizing your work generally.\n\n\n\nAfter all that hard work on the machine learning experiment, you and your colleague could decide to scrap it. It’s perfectly fine to leave branches around and switch back to the main line of development but we can also delete them to tidy up.\n\n\n\nIf, instead, you and your colleague had decided you liked the machine learning experiment, you could also merge the branch with your main development line. Merging branches is analogous to accepting a change in Word’s Track Changes feature but way more powerful and useful.\n\n\n\nA key takeaway here is that Git can drastically increase your confidence and willingness to make changes to your code and help you avoid problems down the road. Analysis rarely follows a linear path and we need a tool that respects this.\n\n\n\nFinally, imagine that, years later, your colleague asks you to make sure the model you reported in a paper you published together was actually the one you used. Another really powerful feature of Git is tags which allow us to record a particular state of our analysis with a meaningful name. In this case, we are lucky because we tagged the version of our code we used to run the analysis. Even if we continued to develop beyond commit 5 (above) after we submitted our manuscript, we can always go back and run the analysis as it was in the past.\n\nWith Git we can enhance our workflow:\n\nEliminate the need for cryptic filenames and comments to track our work.\nProvide detailed descriptions of our changes through commits, making it easier to understand the reasons behind code modifications.\nWork on multiple branches simultaneously, allowing for parallel development, and optionally merge them together.\nUse commits to access and even execute older versions of our code.\nAssign meaningful tags to specific versions of our code.\nAdditionally, Git offers a powerful distributed feature. Multiple individuals can work on the same analysis concurrently on their own computers, with the ability to merge everyone’s changes together.\n\n\n\n\n7.2.2 What exactly are Git and GitHub?\n\nGit:\n\nan open-source distributed version control software\ndesigned to manage the versioning and tracking of source code files and project history\noperates locally on your computer, allowing you to create repositories, track changes, and collaborate with others\nprovides features such as committing changes, branching and merging code, reverting to previous versions, and managing project history\nworks directly with the files on your computer and does not require a network connection to perform most operations\nprimarily used through the command-line interface (CLI, e.g. Terminal), but also has various GUI tools available (e.g. RStudio IDE)\n\n\n\n\n\n\nGitHub:\n\nonline platform and service built around Git\nprovides a centralized hosting platform for Git repositories\nallows us to store, manage, and collaborate on their Git repositories in the cloud\noffers additional features on top of Git, such as a web-based interface, issue tracking, project management tools, pull requests, code review, and collaboration features\nenables easy sharing of code with others, facilitating collaboration and contribution to open source projects\nprovides a social aspect, allowing users to follow projects, star repositories, and discover new code\n\n\n\n\n\n\n\n7.2.3 The Git Life cycle\nAs a Git user, you’ll need to understand the basic concepts associated with versioned sets of changes, and how they are stored and moved across repositories. Any given Git repository can be cloned so that it exists both locally, and remotely. But each of these cloned repositories is simply a copy of all of the files and change history for those files, stored in Git’s particular format. For our purposes, we can consider a Git repository as a folder with a bunch of additional version-related metadata.\nIn a local Git-enabled folder, the folder contains a workspace containing the current version of all files in the repository. These working files are linked to a hidden folder containing the ‘Local repository’, which contains all of the other changes made to the files, along with the version metadata.\nSo, when working with files using Git, you can use Git commands to indicate specifically which changes to the local working files should be staged for versioning (using the git add command), and when to record those changes as a version in the local repository (using the command git commit).\nThe remaining concepts are involved in synchronizing the changes in your local repository with changes in a remote repository. The git push command is used to send local changes up to a remote repository (possibly on GitHub), and the git pull command is used to fetch changes from a remote repository and merge them into the local repository.\nA basic git workflow represented as two islands, one with “local repo” and “working directory”, and another with “remote repo.” Bunnies move file boxes from the working directory to the staging area, then with Commit move them to the local repo. Bunnies in rowboats move changes from the local repo to the remote repo (labeled “PUSH”) and from the remote repo to the working directory (labeled “PULL”).\n\n\n\n\nArtwork by Allison Horst\n\n\n\n\n7.2.4 Let’s Look at a GitHub Repository\nThis screen shows the copy of a repository stored on GitHub, with its list of files, when the files and directories were last modified, and some information on who made the most recent changes.\n\n\n\nIf we drill into the “commits” for the repository, we can see the history of changes made to all of the files. Looks like kellijohnson was working on the project and fixing errors in December:\n\n\n\nAnd finally, if we drill into one of the changes made on December 20, we can see exactly what was changed in each file:\n\n\n\nTracking these changes, how they relate to released versions of software and files is exactly what Git and GitHub are good for. And we will show how they can really be effective for tracking versions of scientific code, figures, and manuscripts to accomplish a reproducible workflow.\n\n\n7.2.5 Git Vocabulary & Commands\nWe know the world of Git and GitHub can be daunting. Use these tables as references while you use Git and GitHub, and we encourage you to build upon this list as you become more comfortable with these tools.\nThis table contains essential terms and commands that complement intro to Git skills. They will get you far on personal and individual projects.\n\nEssential Git Commands\n\n\n\n\n\n\n\nTerm\nGit Command(s)\nDefinition\n\n\n\n\nAdd\ngit add [file]\nStages or adds file changes to the next commit. git add . will stage or add all files.\n\n\nCommit\ngit commit\nRecords changes to the repository with a descriptive message.\n\n\nCommit Message\ngit commit -m\nA descriptive message explaining the changes made in a commit. The message must be within quotes (e.g. “This is my commit message.”).\n\n\nFetch\ngit fetch\nRetrieves changes from a remote repository but does not merge them.\n\n\nPull\ngit pull\nRetrieves and merges changes from a remote repository to the current branch.\n\n\nPush\ngit push\nSends local commits to a remote repository.\n\n\nStage\n-\nThe process of preparing and selecting changes to be included in the next commit.\n\n\nStatus\ngit status\nShows the current status of the repository, including changes and branch information.\n\n\n\nThis table includes more advanced Git terms and commands that are commonly used in both individual and collaborative projects.\n\nAdvanced Git Commands\n\n\n\n\n\n\n\nTerm\nGit Command(s)\nDefinition\n\n\n\n\nBranch\ngit branch\nLists existing branches or creates a new branch.\n\n\nCheckout\ngit checkout [branch]\nSwitches to a different branch or restores files from a specific commit.\n\n\nClone\ngit clone [repository]\nCreates a local copy of a remote repository.\n\n\nDiff\ngit diff\nShows differences between files, commits, or branches.\n\n\nFork\n-\nCreates a personal copy of a repository under your GitHub account for independent development.\n\n\nLog\ngit log\nDisplays the commit history of the repository.\n\n\nMerge\ngit merge [branch]\nIntegrates changes from one branch into another branch.\n\n\nMerge Conflict\n-\nOccurs when Git cannot automatically merge changes from different branches, requiring manual resolution.\n\n\nPull Request (PR)\n-\nA request to merge changes from a branch into another branch, typically in a collaborative project.\n\n\nRebase\ngit rebase\nIntegrates changes from one branch onto another by modifying commit history.\n\n\nRemote\ngit remote\nManages remote repositories linked to the local repository.\n\n\nRepository\ngit init\nA directory where Git tracks and manages files and their versions.\n\n\nStash\ngit stash\nTemporarily saves changes that are not ready to be committed.\n\n\nTag\ngit tag\nAssigns a label or tag to a specific commit.\n\n\n\nGit has a rich set of commands and features, and there are many more terms beyond either table."
  },
  {
    "objectID": "session_07.html#exercise-1-create-a-remote-repository-on-github",
    "href": "session_07.html#exercise-1-create-a-remote-repository-on-github",
    "title": "7  Introduction to Git and GitHub",
    "section": "7.3 Exercise 1: Create a remote repository on GitHub",
    "text": "7.3 Exercise 1: Create a remote repository on GitHub\n\n\n\n\n\n\nSetup\n\n\n\n\nLog into GitHub\nClick the New repository button\nName it {FIRSTNAME}_test\nAdd a short description\nCheck the box to add a README.md file\nAdd a .gitignore file using the R template\nSet the LICENSE to Apache 2.0\n\n\n\nIf you were successful, it should look something like this:\n\n\n\nYou’ve now created your first repository! It has a couple of files that GitHub created for you, like the README.md file, and the LICENSE file, and the .gitignore file.\n\n\n\nFor simple changes to text files, you can make edits right in the GitHub web interface.\n\n\n\n\n\n\nChallenge\n\n\n\nNavigate to the README.md file in the file listing, and edit it by clicking on the pencil icon. This is a regular Markdown file, so you can just add markdown text. Add a new level 2 header called “Purpose” and add some bullet points describing the purpose of the repo. When done, add a commit message, and hit the “Commit changes” button.\n\n\n\n\n\nCongratulations, you’ve now authored your first versioned commit! If you navigate back to the GitHub page for the repository, you’ll see your commit listed there, as well as the rendered README.md file.\n\n\n\nLet’s point out a few things about this window. It represents a view of the repository that you created, showing all of the files in the repository so far. For each file, it shows when the file was last modified, and the commit message that was used to last change each file. This is why it is important to write good, descriptive commit messages. In addition, the header above the file listing shows the most recent commit, along with its commit message, and its SHA identifier. That SHA identifier is the key to this set of versioned changes. If you click on the SHA identifier (6c18e0a), it will display the set of changes made in that particular commit.\n\n\n\n\n\n\nWhat should I write in my commit message?\n\n\n\nWriting effective Git commit messages is essential for creating a meaningful and helpful version history in your repository. It is crucial to avoid skipping commit messages or resorting to generic phrases like “Updates.” When it comes to following best practices, there are several guidelines to enhance the readability and maintainability of the codebase.\nHere are some guidelines for writing effective Git commit messages:\n\nBe descriptive and concise: Provide a clear and concise summary of the changes made in the commit. Aim to convey the purpose and impact of the commit in a few words.\nUse imperative tense: Write commit messages in the imperative tense, as if giving a command. For example, use “Add feature” instead of “Added feature” or “Adding feature.” This convention aligns with other Git commands and makes the messages more actionable.\nSeparate subject and body: Start with a subject line, followed by a blank line, and then provide a more detailed explanation in the body if necessary. The subject line should be a short, one-line summary, while the body can provide additional context, motivation, or details about the changes.\nLimit the subject line length: Keep the subject line within 50 characters or less. This ensures that the commit messages are easily scannable and fit well in tools like Git logs.\nCapitalize and punctuate properly: Begin the subject line with a capital letter and use proper punctuation. This adds clarity and consistency to the commit messages.\nFocus on the “what” and “why”: Explain what changes were made and why they were made. Understanding the motivation behind a commit helps future researchers and collaborators (including you!) comprehend its purpose.\nUse present tense for subject, past tense for body: Write the subject line in present tense as it represents the current state of the codebase. Use past tense in the body to describe what has been done.\nReference relevant issues: If the commit is related to a specific issue or task, include a reference to it. For example, you can mention the issue number or use keywords like “Fixes,” “Closes,” or “Resolves” followed by the issue number."
  },
  {
    "objectID": "session_07.html#exercise-2-clone-your-repository-and-use-git-locally-in-rstudio",
    "href": "session_07.html#exercise-2-clone-your-repository-and-use-git-locally-in-rstudio",
    "title": "7  Introduction to Git and GitHub",
    "section": "7.4 Exercise 2: clone your repository and use Git locally in RStudio",
    "text": "7.4 Exercise 2: clone your repository and use Git locally in RStudio\nIn this exercise, we’ll use the GitHub URL for the GitHub repository you created to clone the repository onto your local machine so that you can edit the files in RStudio.\nStart by copying the GitHub URL, which represents the repository location:\n\n\n\n\n\n\n\nRStudio knows how to work with files under version control with Git, but only if you are working within an R project folder.\nNext, let’s clone the repository created on GitHub so we have it accessible as an R project in RStudio.\n\n\n\n\n\n\nAn important distinction\n\n\n\nWe refer to the remote copy of the repository that is on GitHub as the origin repository (the one that we cloned from), and the copy on our local computer as the local repository.\n\n\n\n\n\n\n\n\nSetup\n\n\n\n\nIn the File menu, select “New Project”\nIn the dialog that pops up, select the “Version Control” option, and paste the GitHub URL that you copied into the field for the remote repository Repository URL\nWhile you can name the local copy of the repository anything, it’s typical to use the same name as the GitHub repository to maintain the correspondence\n\n\n\n\n\n\n\n\nOnce you hit “Create Project”, a new RStudio window will open with all of the files from the remote repository copied locally. Depending on how your version of RStudio is configured, the location and size of the panes may differ, but they should all be present, including a Git tab and the normal Files tab listing the files that had been created in the remote repository.\n\n\n\nYou’ll note that there is one new file halina_test.Rproj, and three files that we created earlier on GitHub (.gitignore, LICENSE, and README.md).\nIn the Git tab, you’ll note that two files are listed. This is the status pane that shows the current modification status of all of the files in the repository. In this case, the .gitignore file is listed as M for Modified, and halina_test.Rproj is listed with a ?? to indicate that the file is untracked. This means that Git has not stored any versions of this file, and knows nothing about the file. As you make version control decisions in RStudio, these icons will change to reflect the current version status of each of the files.\nInspect the history. For now, let’s click on the History button in the Git tab, which will show the log of changes that occurred, and will be identical to what we viewed on GitHub. By clicking on each row of the history, you can see exactly what was added and changed in each of the two commits in this repository.\n\n\n\n\n\n\n\nChallenge\n\n\n\n\nLet’s make a change to the README.md file, this time from RStudio, then commit the README.md change\nAdd a new section to your README.md called “Creator” using a level 2 header, and under it include some information about yourself. Bonus: Add some contact information and link your email using Markdown syntax\n\n\n\nOnce you save, you’ll immediately see the README.md file show up in the Git tab, marked as a modification. You can select the file in the Git tab, and click Diff to see the differences that you saved (but which are not yet committed to your local repository).\n\nAnd here’s what the newly made changes look like compared to the original file. New lines are highlighted in green, while removed lines are in red.\n\nCommit the RStudio changes. To commit the changes you made to the README.md file, check the Staged checkbox next to the file (which tells Git which changes you want included in the commit), then provide a descriptive commit message, and then click “Commit”.\n\nNote that some of the changes in the repository, namely halina_test.Rproj are still listed as having not been committed. This means there are still pending changes to the repository. You can also see the note that says:\nYour branch is ahead of ‘origin/main’ by 1 commit.\nThis means that we have committed 1 change in the local repository, but that commit has not yet been pushed up to the origin repository, where origin is the typical name for our remote repository on GitHub. So, let’s commit the remaining project files by staging them and adding a commit message.\n\nWhen finished, you’ll see that no changes remain in the Git tab, and the repository is clean.\nInspect the history. Note that the message now says:\nYour branch is ahead of ‘origin/main’ by 2 commits.\nThese 2 commits are the two we just made, and have not yet been pushed to GitHub. By clicking on the “History” button, we can see that there are now a total of four commits in the local repository (while there had only been two on GitHub).\n\nPush these changes to GitHub. Now that everything has been changed as desired locally, you can push the changes to GitHub using the Push button. This will prompt you for your GitHub username and password, and upload the changes, leaving your repository in a totally clean and synchronized state. When finished, looking at the history shows all four commits, including the two that were done on GitHub and the two that were done locally on RStudio.\n\n\n\nAnd note that the labels indicate that both the local repository (HEAD) and the remote repository (origin/HEAD) are pointing at the same version in the history. So, if we go look at the commit history on GitHub, all the commits will be shown there as well.\n\n\n\n\n\n\n\n\n\nLast thing, some Git configuration\n\n\n\nWhen Git released version 2.27, a new feature they incorporated allows users to specify how to pull (essentially), otherwise a warning will appear. To suppress this warning we need to configure our Git with this line of code:\ngit config pull.rebase false\npull.rebase false is a default strategy for pulling where it will try to auto-merge the files if possible, and if it can’t it will show a merge conflict"
  },
  {
    "objectID": "session_07.html#exercise-3-setting-up-git-on-an-existing-project",
    "href": "session_07.html#exercise-3-setting-up-git-on-an-existing-project",
    "title": "7  Introduction to Git and GitHub",
    "section": "7.5 Exercise 3: Setting up Git on an existing project",
    "text": "7.5 Exercise 3: Setting up Git on an existing project\nNow you have two projects set up in your RStudio environment, training_{USERNAME} and {FIRSTNAME}_test. We set you up with the {FIRSTNAME}_test project since we think it is an easy way to introduce you to Git, but more commonly researchers will have an existing directory of code that they then want to make a Git repository out of. For the last exercise of this session, we will do this with your training_{USERNAME} project.\nFirst, switch to your training_{USERNAME} project using the RStudio project dropdown menu. The project dropdown menu is in the upper right corner of your RStudio pane. Click the dropdown next to your project name ({FIRSTNAME}_test), and then select the training_{USERNAME} project from the “recent projects” list.\n\n\n\n\n\nNext, from the Tools menu, select “Project Options.” In the dialog that pops up, select “Git/SVN” from the menu on the left. In the dropdown at the top of this page, select Git and click “Yes” in the confirmation box. Click “Yes” again to restart RStudio.\nWhen RStudio restarts, you should have a Git tab, with two untracked files (.gitignore and training_{USERNAME}.Rproj).\n\n\n\n\n\n\nChallenge\n\n\n\nAdd and commit the .gitignore and training_{USERNAME}.Rproj files to your Git repository.\n\n\nNow we have your local repository all set up. You can make as many commits as you want on this repository, and it will likely still be helpful to you, but the power in Git and GitHub is really in collaboration. As discussed, GitHub facilitates this, so let’s get this repository on GitHub.\n\n\n\n\n\n\nSetup\n\n\n\n\nGo to GitHub, and click on the “New Repository” button.\nIn the repository name field, enter the same name as your R Project. So for me, this would be training_dolinh.\nAdd a description, keep the repository public, and, most importantly: DO NOT INITIALIZE THE REPOSITORY WITH ANY FILES. We already have the repository set up locally so we don’t need to do this. Initializing the repository will only cause merge issues.\n\nHere is what your page should look like:\n\n\n\n\n\n\nClick the “Create repository” button.\n\n\n\nThis will open your empty repository with a page that conveniently gives you exactly the instructions you need. In our case, we are going to “push an existing repository from the command line.”\n\n\n\nClick the clipboard icon to copy the code for the middle option of the three on this page. It should have three lines and look like this:\ngit remote add origin https://github.com/hdolinh/training_dolinh.git\ngit branch -M main\ngit push -u origin main\nBack in RStudio, open the terminal by clicking the Terminal tab next to the Console tab. The prompt should look something like this:\ndolinh@included-crab:~/training_dolinh$\nIn the prompt, paste the code that you copied from the GitHub page and press return.\nThe code that you copied and pasted did three things:\n\nAdded the GitHub repository as the remote repository\nRenamed the default branch to main\nPushed the main branch to the remote GitHub repository\n\nIf you go back to your browser and refresh your GitHub repository page, you should now see your files appear.\n\n\n\n\n\n\nChallenge\n\n\n\nOn your repository page, GitHub has a button that will help you add a README.md file. Click the “Add a README” button and use markdown syntax to create a README.md Commit the changes to your repository.\nGo to your local repository (in RStudio) and pull the changes you made."
  },
  {
    "objectID": "session_07.html#go-further-with-git",
    "href": "session_07.html#go-further-with-git",
    "title": "7  Introduction to Git and GitHub",
    "section": "7.6 Go further with Git",
    "text": "7.6 Go further with Git\nThere’s a lot we haven’t covered in this brief tutorial. There are some great and much longer tutorials that cover advanced topics, such as:\n\nUsing Git on the command line\nResolving conflicts\nBranching and merging\nPull requests versus direct contributions for collaboration\nUsing .gitignore to protect sensitive data\nGitHub Issues - how to use them for project management and collaboration\n\nand much, much more."
  },
  {
    "objectID": "session_07.html#git-resources",
    "href": "session_07.html#git-resources",
    "title": "7  Introduction to Git and GitHub",
    "section": "7.7 Git resources",
    "text": "7.7 Git resources\n\nPro Git Book\nHappy Git and GitHub for the useR\nGitHub Documentation\nLearn Git Branching is an interactive tool to learn Git on the command line\nSoftware Carpentry Version Control with Git\nBitbucket’s tutorials on Git Workflows"
  },
  {
    "objectID": "session_08.html#learning-objectives",
    "href": "session_08.html#learning-objectives",
    "title": "8  Reproducible Data Access",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nBest practices for reproducible data access\nAccessing data on the web and with pins\nHow content identifiers differ from DOIs\nHow content identifiers make research more reproducible\nWays to register and resolve content identifiers for unpublished data\nHow content identifiers can resolve to published data sources"
  },
  {
    "objectID": "session_08.html#reproducible-data-access",
    "href": "session_08.html#reproducible-data-access",
    "title": "8  Reproducible Data Access",
    "section": "8.1 Reproducible Data Access",
    "text": "8.1 Reproducible Data Access"
  },
  {
    "objectID": "session_08.html#barriers-to-data-access",
    "href": "session_08.html#barriers-to-data-access",
    "title": "8  Reproducible Data Access",
    "section": "8.2 Barriers to data access",
    "text": "8.2 Barriers to data access\nTraditional ways of working with data – as files on a file system – limit the reproducibility of code to local compute environments. A typical R analysis file will load one or many data files from the local disk with code like this:\n\ndelta_catch &lt;- readr::read_csv('/Users/jkresearcher/Projects/2018/Delta_Analysis/delta_catch.csv')\ndelta_taxa &lt;- readr::read_csv('../../Delta_2021/delta_taxa.csv')\ndelta_effort &lt;- readr::read_csv('delta_effort.csv')\ndelta_sites &lt;- readr::read_csv('data/delta_sites.csv')\n\nWhich of those file paths are the most portable? And which will run unmodified on both the original computer that they were written on, and on colleagues’ computers? In reality, none of them, in that they require that a specific data file be present in a specific location for the code to work properly, and these assumptions are rarely met and hard to maintain. In practice, the relative paths are reasonably robust, as long as the code and data are shipped together, such as in a GitHub repository. Hardcoded paths like these are often spread deeply through the scripts that researchers write, and can become a surprise when they are encountered during execution."
  },
  {
    "objectID": "session_08.html#web-urls-for-data-access",
    "href": "session_08.html#web-urls-for-data-access",
    "title": "8  Reproducible Data Access",
    "section": "8.3 Web URLs for data access",
    "text": "8.3 Web URLs for data access\nThe Web partly solves this problem, because it allows code to access data that is located somewhere on the Internet with a web URI. For example, loading data from a web site can be much more portable than loading the equivalent data from a local computer.\n\ndelta_sites_edi &lt;- 'https://portal.edirepository.org/nis/dataviewer?packageid=edi.233.2&entityid=6a82451e84be1fe82c9821f30ffc2d7d'\n\ndelta_sites &lt;- readr::read_csv(delta_sites_edi, show_col_types = FALSE)\n\nhead(delta_sites)\n\n# A tibble: 6 × 4\n  MethodCode StationCode LatitudeLocation LongitudeLocation\n  &lt;chr&gt;      &lt;chr&gt;                  &lt;dbl&gt;             &lt;dbl&gt;\n1 BSEIN      AL1                     38.5             -122.\n2 BSEIN      AL2                     38.5             -122.\n3 BSEIN      AL3                     38.5             -122.\n4 BSEIN      AL4                     38.5             -122.\n5 BSEIN      BL1                     38.5             -122.\n6 BSEIN      BL2                     38.4             -122.\n\n\nIn theory, that code will work from anyone’s computer with an internet connection. But code that downloads data each and every time it is run is not particularly efficient, and will be prohibitive for all but the smallest datasets. A simple solution to this issue is to cache a local copy of the dataset, and only retrieve the original from the web when we don’t have a local copy. In this way, people running code or a script will download the data the first time their code is run, but use a local copy from thence forward. While this can be accomplished with some simple conditional logic in R, the pattern has been simplified using the pins package:\n\ndelta_sites_edi &lt;- pins::pin('https://portal.edirepository.org/nis/dataviewer?packageid=edi.233.2&entityid=6a82451e84be1fe82c9821f30ffc2d7d')\n\ndelta_sites &lt;- readr::read_csv(delta_sites_edi, show_col_types = FALSE)\nhead(delta_sites)\n\n# A tibble: 6 × 4\n  MethodCode StationCode LatitudeLocation LongitudeLocation\n  &lt;chr&gt;      &lt;chr&gt;                  &lt;dbl&gt;             &lt;dbl&gt;\n1 BSEIN      AL1                     38.5             -122.\n2 BSEIN      AL2                     38.5             -122.\n3 BSEIN      AL3                     38.5             -122.\n4 BSEIN      AL4                     38.5             -122.\n5 BSEIN      BL1                     38.5             -122.\n6 BSEIN      BL2                     38.4             -122.\n\n\nYou’ll note that code takes longer the first time it is run, as the data file is downloaded only the first time. While this works well over the short term, abundant evidence shows that web URIs have short lifespan. Most URIs are defunct within a few years (e.g., see McCown et al. 2005). Only the most carefully curated web sites maintain the viability of their links for longer. And maintaining them for decade-long periods requires a focus on archival principles and dedicated staff to ensure that files and the URLs at which they are published remain accessible. This is precisely the role of archival data repositories like the Arctic Data Center, the KNB Data Repository, and the Environmental Data Initiative (EDI)."
  },
  {
    "objectID": "session_08.html#dois-and-data-access",
    "href": "session_08.html#dois-and-data-access",
    "title": "8  Reproducible Data Access",
    "section": "8.4 DOIs and data access",
    "text": "8.4 DOIs and data access\nFinally, no discussion of data access and persistence would be complete without discussing the use of Digital Object Identifiers (DOIs). DOIs have become the dominant means to create persistent links to academic articles, publications, and datasets. As authority-based identifiers, they work when an authority assigns a DOI name to a published work, and then ensures that the DOI name always redirects to the current web location of the resource. This is a lot of work, and there is no guarantees that the authorities will keep the links up-to-date. Journals, societies, and data repositories actively maintain the redirection between a DOI such as doi:10.6073/pasta/b0b15aef7f3b52d2c5adc10004c05a6f and its current location on the EDI Repository. DOIs are commonly assigned to published datasets, and include the bibliographic metadata needed to properly cite and access the dataset.\nThe challenge with DOIs as they are typically implemented is that they are usually assigned to a Dataset, which is a collection of digital objects that are composed to form the whole Dataset and that can be accessed individually or through an API. Typically, the metadata attached to DOIs does not include an enumeration of those digital objects or a clear mechanism to get to the actual data – rather, the DOI redirects to a dataset landing page that provides a human readable summary of the dataset, and often various types of links to find and eventually download the data. Despite advances in metadata interoperability from DCAT and schema.org/Dataset, there is currently no reliable way to universally go from a known DOI for a dataset to the list of current locations of all of the digital objects that compose that dataset. And yet, this is exactly what we need for portable and persistent data access. In addition, we frequently work with data that doesn’t have a DOI yet as we are creating derived data products for analysis locally before they are published. In conclusion, DOIs are a great approach to uniquely citing a dataset, but they do not provde a way for code to download specific, versioned digital objects from a dataset in a portable way that is persistent over many years.\nThus, we want data access to be:\n\nPortable – works for anyone, even if they don’t already have the data\nPersistent – over long time periods\nVersioned – the specific version of data used is guaranteed to be returned\nTraceable – references to the provenance of data processing can be made\nTransparent – it is clear from the script what data were used\nCitable – it is clear how to properly cite the associated Dataset for attribution"
  },
  {
    "objectID": "session_08.html#content-based-identifiers",
    "href": "session_08.html#content-based-identifiers",
    "title": "8  Reproducible Data Access",
    "section": "8.5 Content-based identifiers",
    "text": "8.5 Content-based identifiers\nA powerful approach to solving these problems is by using content-based identifiers, rather than authority-based identifiers like DOIs. A content-based identifier, or contentid for short, can be calculated from the content in a data file itself, and is unique (within constraints) to that content. This is accomplished by using a “hash” function, which calculates a relatively short, fixed-length, and unique value for any given input. Hash functions form the basis of secure cryptography for secure messaging, and so there are many tools available for conveniently hashing data inputs. In our use case, we can use commonly available cryptographic hash functions (such as SHA-256 and SHA-1) to calculate a unique identifier for any given file. This gives us a unique identifier for the file which can be calculated by anyone with a copy of the file, and which can be registered as metadata in repositories that hold those files.\n\nOnce we have a content identifier for an object, we can cache the file locally (just like we did with pins), and we can query repositories to see if they contain a copy of that file. Unlike authority-based identifiers, anyone who possesses a copy of a specific version of a data file can calculate the content-identifier for it, enabling us to build systems to find and access those data files across the repository landscape, and really across any web-accessible location. This has all of the power of cacheing and pinning web resources that we demonstrated before, but has the advantage that all holders of the content will use an identical identifier, avoiding broken links. And because content-identifiers can be determined locally before files are published on the web, we can use them in our scripts for data files that have yet to be published and yet know that they will work for others once the files have been published in a repository."
  },
  {
    "objectID": "session_08.html#persistent-and-portable-data-access-for-improving-reproducibility",
    "href": "session_08.html#persistent-and-portable-data-access-for-improving-reproducibility",
    "title": "8  Reproducible Data Access",
    "section": "8.6 Persistent and portable data access for improving reproducibility",
    "text": "8.6 Persistent and portable data access for improving reproducibility\nWe’ll be working with the following IEP dataset that is stored on EDI:\n\nInteragency Ecological Program (IEP), B. Schreier, B. Davis, and N. Ikemiyagi. 2019. Interagency Ecological Program: Fish catch and water quality data from the Sacramento River floodplain and tidal slough, collected by the Yolo Bypass Fish Monitoring Program, 1998-2018. ver 2. Environmental Data Initiative. https://doi.org/10.6073/pasta/b0b15aef7f3b52d2c5adc10004c05a6f (Accessed 2021-10-30).\n\nYou can view this IEP dataset on DataONE:\n It also is visible from the EDI dataset landing page:\n\nIt contains several data files, each of which is at a specific web URI, including:\n\nFish catch and water quality\nFish taxonomy\nTrap Effort\nSite locations\n\nHere are the URLs for these 4 data files as registered on DataONE:\n\ndelta_catch_url &lt;- \"https://cn.dataone.org/cn/v2/resolve/https%3A%2F%2Fpasta.lternet.edu%2Fpackage%2Fdata%2Feml%2Fedi%2F233%2F2%2F015e494911cf35c90089ced5a3127334\"\ndelta_taxa_url &lt;- \"https://cn.dataone.org/cn/v2/resolve/https%3A%2F%2Fpasta.lternet.edu%2Fpackage%2Fdata%2Feml%2Fedi%2F233%2F2%2F0532048e856d4bd07deea11583b893dd\"\ndelta_effort_url &lt;- \"https://cn.dataone.org/cn/v2/resolve/https%3A%2F%2Fpasta.lternet.edu%2Fpackage%2Fdata%2Feml%2Fedi%2F233%2F2%2Face1ef25f940866865d24109b7250955\"\ndelta_sites_url &lt;- \"https://cn.dataone.org/cn/v2/resolve/https%3A%2F%2Fpasta.lternet.edu%2Fpackage%2Fdata%2Feml%2Fedi%2F233%2F2%2F6a82451e84be1fe82c9821f30ffc2d7d\"\n\nAnd here are the URLS of these four data files as presented on EDI:\n\ndelta_catch_edi &lt;- 'https://portal.edirepository.org/nis/dataviewer?packageid=edi.233.2&entityid=015e494911cf35c90089ced5a3127334'\ndelta_taxa_edi &lt;- 'https://portal.edirepository.org/nis/dataviewer?packageid=edi.233.2&entityid=0532048e856d4bd07deea11583b893dd'\ndelta_effort_edi &lt;- 'https://portal.edirepository.org/nis/dataviewer?packageid=edi.233.2&entityid=ace1ef25f940866865d24109b7250955'\ndelta_sites_edi &lt;- 'https://portal.edirepository.org/nis/dataviewer?packageid=edi.233.2&entityid=6a82451e84be1fe82c9821f30ffc2d7d'\n\nSo, these data files are available from two different web locations. Do they produce the same data? Are the files identical? The contentid package can answer those questions for us."
  },
  {
    "objectID": "session_08.html#storing-a-content-identifier-from-a-uri",
    "href": "session_08.html#storing-a-content-identifier-from-a-uri",
    "title": "8  Reproducible Data Access",
    "section": "8.7 Storing a content identifier from a URI",
    "text": "8.7 Storing a content identifier from a URI\nLet’s use the contentid package for portable access to data. First, using a web URI, store the content identifier in your local content registry to cache it on your machine. The contentid::store() function retrieves the data from the URL, calculates a hash value for the content, and stores both in a local registry on your machine. This is very similar to the pins::pin function, but it uses the content identifier to point to the data.\n\ndelta_catch_id &lt;- store(delta_catch_url)\ndelta_taxa_id &lt;- store(delta_taxa_url)\ndelta_effort_id &lt;- store(delta_effort_url)\ndelta_sites_id &lt;- store(delta_sites_url)\n\nprint(c(delta_catch_id=delta_catch_id, \n        delta_taxa_id=delta_taxa_id,\n        delta_effort_id=delta_effort_id, \n        delta_sites_id=delta_sites_id))\n\n                                                                  delta_catch_id \n\"hash://sha256/e0dc10d7f36cfc5ac147956abb91f24f2b2df9f914a004bbf1e85e7d9cf52f41\" \n                                                                   delta_taxa_id \n\"hash://sha256/1473de800f3c5577da077507fb006be816a9194ddd417b1b98836be92eaea49d\" \n                                                                 delta_effort_id \n\"hash://sha256/f2433efab802f55fa28c4aab628f3d529f4fdaf530bbc5c3a67ab92b5e8f71b2\" \n                                                                  delta_sites_id \n\"hash://sha256/e25498ffc0208c3ae0e31a23204b856a9309f32ced2c87c8abcdd6f5cef55a9b\""
  },
  {
    "objectID": "session_08.html#loading-data-from-a-content-identifier",
    "href": "session_08.html#loading-data-from-a-content-identifier",
    "title": "8  Reproducible Data Access",
    "section": "8.8 Loading data from a content identifier",
    "text": "8.8 Loading data from a content identifier\nOnce you have the content identifier for a data file of interest (e.g., delta_catch_id in this case), you can call contentid::resolve() to find the locations where that data is stored. Because you already have it stored locally, it returns the file path to the file on your local registry, which you can then use to load the data into a data frame or process the data as needed.\n\ndelta_catch_file &lt;- contentid::resolve(delta_catch_id, store = TRUE)\ndelta_catch &lt;- readr::read_csv(delta_catch_file, show_col_types=FALSE)\nhead(delta_catch)\n\n# A tibble: 6 × 32\n  SampleDate SampleTime StationCode MethodCode GearID   CommonName       \n  &lt;chr&gt;      &lt;time&gt;     &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;            \n1 1/16/1998  14:05      YB          BSEIN      SEIN50   Threadfin Shad   \n2 1/16/1998  15:00      YB          BSEIN      SEIN50   Inland Silverside\n3 1/19/1998  12:17      YB          FNET       FKNT     Threadfin Shad   \n4 1/19/1998  12:17      YB          FNET       FKNT     Chinook Salmon   \n5 1/19/1998  11:00      YB          PSEIN      PSEIN100 Threadfin Shad   \n6 1/19/1998  11:30      YB          PSEIN      PSEIN100 Inland Silverside\n# ℹ 26 more variables: GeneticallyConfirmed &lt;chr&gt;, GeneticID &lt;lgl&gt;,\n#   Field_ID_CommonName &lt;chr&gt;, ForkLength &lt;dbl&gt;, Count &lt;dbl&gt;, FishSex &lt;chr&gt;,\n#   Race &lt;chr&gt;, MarkCode &lt;chr&gt;, CWTSample &lt;lgl&gt;, FishTagID &lt;chr&gt;,\n#   StageCode &lt;chr&gt;, Dead &lt;chr&gt;, GearConditionCode &lt;dbl&gt;, WeatherCode &lt;chr&gt;,\n#   WaterTemperature &lt;dbl&gt;, Secchi &lt;dbl&gt;, Conductivity &lt;dbl&gt;, SpCnd &lt;dbl&gt;,\n#   DO &lt;dbl&gt;, pH &lt;dbl&gt;, Turbidity &lt;dbl&gt;, SubstrateCode &lt;chr&gt;, Tide &lt;chr&gt;,\n#   VolumeSeined &lt;dbl&gt;, Latitude &lt;dbl&gt;, Longitude &lt;dbl&gt;\n\n# And two more examples\ndelta_taxa_file &lt;- contentid::resolve(delta_taxa_id, store = TRUE)\ndelta_taxa &lt;- readr::read_csv(delta_taxa_file, show_col_types=FALSE)\n\ndelta_sites_file &lt;- contentid::resolve(delta_sites_id, store = TRUE)\ndelta_sites &lt;- readr::read_csv(delta_sites_file, show_col_types = FALSE)\n\nThis approach is portable, as anyone can run it without having the data local beforehand. This is because resolve(id) will store the data locally if someone does not already have a copy of the data in their local cache. This works by consulting a number of well-know registries to discover the location of the files, including DataONE, Hash Archive, Zenodo, and Software Heritage.\nThis approach is persistent, because it pulls data from these persistent archives, and can take advantage of archive redundancy to locate a file even if it has moved to a new URL location (assuming that new location has been registered).\nThis approach is reproducible, as the exact version of the data will be used every time (even if someone changes the data at the original web URI, which would require a new content identifier).\nThis approach is traceable because there is a reference in the code to the specific data used based on in its content identifier, and the only way to change which data are used is to change the checksum that is being referenced to a new version."
  },
  {
    "objectID": "session_08.html#storing-and-using-local-data-identifiers",
    "href": "session_08.html#storing-and-using-local-data-identifiers",
    "title": "8  Reproducible Data Access",
    "section": "8.9 Storing and using local data identifiers",
    "text": "8.9 Storing and using local data identifiers\nBecause not all data are already published, it is also helpful to being working with content identifiers before the data are made public on the web. This is easily accomplished by storing a file in the local registry, and then using its content identifier during analysis.\n\n# Store a local file\nvostok_co2 &lt;- system.file(\"extdata\", \"vostok.icecore.co2\", package = \"contentid\")\nvostok_id &lt;- store(vostok_co2)\nvostok &lt;- contentid::resolve(vostok_id, store=TRUE)\nco2 &lt;- read.table(vostok, col.names = c(\"depth\", \"age_ice\", \"age_air\", \"co2\"), skip = 21)\nhead(co2)\n\n  depth age_ice age_air   co2\n1 149.1    5679    2342 284.7\n2 173.1    6828    3634 272.8\n3 177.4    7043    3833 268.1\n4 228.6    9523    6220 262.2\n5 250.3   10579    7327 254.6\n6 266.0   11334    8113 259.6\n\n\nFor this point forward, we can\n\ncontentid::sources(vostok_id)\n\n                                                                                                               source\n1 /home/runner/.local/share/R/contentid/sha256/94/12/9412325831dab22aeebdd674b6eb53ba6b7bdd04bb99a4dbb21ddff646287e37\n2                                https://zenodo.org/api/files/5967f986-b599-4492-9a08-94ce32323dc2/vostok.icecore.co2\n3                https://data.ess-dive.lbl.gov/catalog/d1/mn/v2/object/ess-dive-642bb2e5bd48452-20180716T160320693400\n                 date\n1 2023-06-28 05:37:32\n2 2023-05-22 09:41:20\n3 2023-01-16 00:58:23\n\n\nLater, when the data file is published to a DataONE repository, or Zenodo or other supported repositories, the script will work for other people trying to access it via contentid::resolve()."
  },
  {
    "objectID": "session_08.html#citing-content-identifiers",
    "href": "session_08.html#citing-content-identifiers",
    "title": "8  Reproducible Data Access",
    "section": "8.10 Citing content identifiers",
    "text": "8.10 Citing content identifiers\nAlthough content identifiers are excellent from a reproducibility perspective, they are unfortunately not directly linked to DOIs that are commonly used for citing data. DOIs are the current standard for citing data, and carry the citation metadata for data packages (such as author, title, publication year, etc.). But the contentid package currently lacks a mechanism to determine the citation for a file that is used in a script. Fortunately. because data networks like DataONE maintain the association between each content-identifier that is registered there with the assigned DOI for the Dataset that the object is part of, retrieve the citation for a given content identifier from the DataONE network.\nFor example, if the data is on DataONE, we could write a function to lookup the citation:\n\ncite_string &lt;- lookup_citation(vostok_id)\n\nAnd this can even be displayed inline in the markdown text. For example, this chapter used data from:\n\nM. R. Manning,W. H. Melhuish. 1997. Atmospheric 14C record from Wellington, New Zealand. ESS-DIVE. ess-dive-4694e4db5ef14ce-20180726T003323574 https://search.dataone.org/view/ess-dive-4694e4db5ef14ce-20180726T003323574"
  },
  {
    "objectID": "session_08.html#challenges-and-future-work",
    "href": "session_08.html#challenges-and-future-work",
    "title": "8  Reproducible Data Access",
    "section": "8.11 Challenges and future work",
    "text": "8.11 Challenges and future work\nThe contentid package is a work in progress. One challenge is that content identifiers are opaque, and not particularly transparent. For many researchers, seeing the long hash value in a script will not be very meaningful. In addition, the contentid package needs mechanisms to transparently indicate what a content identifier refers to. Again, we have this information available dynamically through the metadata collated in networks like DataONE. A useful extension to contentid would be to provide functions for displaying detailed metadata about a content identifier when it is available, as well as a mechanism to provide more human-readable aliases for the identifier.\nAnother major challenge is that most repositories don’t register content identifiers with registries that support search and discovery. So, use of these identifiers can be challenging while we build a critical mass of repositories that provide seamless access to their data via content identifiers.\nThese types of ideas for extension are how the R ecosystem advances. Anyone who sees a better way to extend packages like contentid can do so, or even create their own packages to explore new approaches to reproducible data access."
  },
  {
    "objectID": "session_09.html#learning-objectives",
    "href": "session_09.html#learning-objectives",
    "title": "9  Data Modeling Essentials",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nLearn how to design and create effective data tables by:\n\napplying tidy and normalized data principles,\nfollowing best practices to format data tables’ content,\nrelating tables following relational data models principles, and\nunderstanding how to perform table joins."
  },
  {
    "objectID": "session_09.html#tidy-data",
    "href": "session_09.html#tidy-data",
    "title": "9  Data Modeling Essentials",
    "section": "9.1 Tidy Data",
    "text": "9.1 Tidy Data\n\n9.1.1 Values, variables, observations, and entities\nBefore we dive into tidy data, we need to get acquainted with our building blocks. A dataset is a collection of values, with each value belonging to an observation and a variable.\n\nAn observation groups all the values measured for an individual entity. For example, an observation about a plant could include the species name, date of collection and altitude of the place where the plant was found. The plants found would be the entity.\nA variable groups all the values that measure the same attribute. In the previous example, the variables would be the date of collection, altitude and species name.\n\n\n\n\n\n\n\nNote\n\n\n\n“Variable” is a general term that covers multiple types of attributes. For example, when we are collecting data to investigate a causal relationship, variables include both explanatory variables (also called independent variables) and response variables (also called dependent variables). We could also have a classifier variable that assigns a unique identifier to each observation.\nWhen we want to document our values, we must think of the best way to organize them so they clearly relate to the variables they represent and the observations they belong to.\n\n\n\n\n9.1.2 What is tidy data?\nTidy data is a standardized way of organizing data tables that allows us to manage and analyze data efficiently, because it makes it straightforward to understand the corresponding variable and observation of each value. The tidy data principles are:\n\nEvery column is a variable.\nEvery row is an observation.\nEvery cell is a single value.\n\nThe following is an example of tidy data - it’s easy to see the three tidy data principles apply.\n\n\n\n\n\n\n9.1.3 Recognizing untidy data\nAnything that does not follow the three tidy data principles is untidy data.\nThere are many ways in which data can become untidy, some can be noticed right away, while others are more subtle. In this section we will look at some examples of common untidy data situations.\n\n9.1.3.1 Example 1\nThe following is a screenshot of an actual dataset that came across NCEAS. We have all seen spreadsheets that look like this - and it is fairly obvious that whatever this is, it isn’t very tidy. Let’s dive deeper into why we consider it untidy data.\n\n\n9.1.3.1.1 Multiple tables\nTo begin with, notice there are actually three smaller tables within this table. Although for our human brain it is easy to see and interpret this, it is extremely difficult to get a computer to see it this way.\n\nHaving multiple tables within the same table will create headaches down the road should you try to read in this information using R or another programming language. Having multiple tables immediately breaks the tidy data principles, as we will see next.\n\n\n9.1.3.1.2 Inconsistent columns\nIn tidy data, each column corresponds to a single variable. If you look down a column, and see that multiple variables exist in the table, the data is not tidy. A good test for this can be to see if you think the column consists of only one unit type.\n\n\n\n9.1.3.1.3 Inconsistent rows\nThe second principle of tidy data is: every column must be a single observation. If you look across a single row, and you notice that there are clearly multiple observations in one row, the data are likely not tidy.\n\n\n\n9.1.3.1.4 Marginal sums and statistics\nMarginal sums and statistics are not considered tidy. They break principle one, “Every column is a variable”, because a marginal statistic does not represent the same variable as the values it is summarizing. They also break principle two, “Every row is an observation”, because they represent a combination of observations, rather than a single one.\n\n\n\n\n9.1.3.2 Example 2\nConsider the following table. It’s a single one this time! It shows data about species observed at a specific site and date. The column headers refer to the following:\n\nid: id of row\ndate: date when a species was observed\nsite: site where a species was observed\nname: site’s name\naltitude: site’s altitude\nsp1code, sp2code: species code for two plants observed\nsp1height, sp2height: height of the animals observed\n\nTake a moment to see why this is not tidy data.\n\n\n9.1.3.2.1 Multiple Observations\nRemember that an observation is all the values measured for an individual entity. If our entity is a single observed animal, then the values we measured are date and site of observation, the temperature, and the species code and height. This table breaks the second tidy data principles: Every row is an observation.\n\nPeople often refer to this as “wide format”, because the observations are spread across a wide number of columns. Note that, should one encounter a new species in the survey, we would have to add new columns to the table. This is difficult to analyze, understand, and maintain. To solve this problem, we can create a single column for species code and a single column for species height as in the following table."
  },
  {
    "objectID": "session_09.html#data-normalization",
    "href": "session_09.html#data-normalization",
    "title": "9  Data Modeling Essentials",
    "section": "9.2 Data Normalization",
    "text": "9.2 Data Normalization\n\n9.2.1 What is data normalization?\nData normalization is the process of creating normalized data, which are datasets free from data redundancy to simplify query, analysis, storing, and maintenance. In normalized data we organize data so that :\n\nEach table follows the tidy data principles\nWe have separate tables for each type of entity measured\nObservations (rows) are all unique\nEach column represents either an identifying variable or a measured variable\n\nIn denormalized data observations about different entities are combined. A good indication that a data table is denormalized and needs normalization is seeing the same column values repeated across multiple rows.\n\n\n9.2.2 Example\nIn the previous data table the row values for the last three columns are repeated.\n\nThis means the data is denormalized and it happens because each row has measurements about multiple entities:\n\n1st entity: individual plants found at that site, and\n2nd entity: sites at which the plants were observed.\n\n\nIf we use this information to normalize our data, we should end up with:\n\none tidy table for each entity observed, and\nadditional columns for identifying variables (such as site ID).\n\nHere’s how our normalized data would look like:\n\nNotice that each table also satisfies the tidy data principles.\nNormalizing data by separating it into multiple tables often makes researchers really uncomfortable. This is understandable! The person who designed this study collected all of these measurements for a reason - so that they could analyze the measurements together. Now that our site and plant information are in separate tables, how would we use site temperature as a predictor variable for species composition, for example? We will go over a solution in the next section."
  },
  {
    "objectID": "session_09.html#relational-data-models",
    "href": "session_09.html#relational-data-models",
    "title": "9  Data Modeling Essentials",
    "section": "9.3 Relational Data Models",
    "text": "9.3 Relational Data Models\n\n9.3.1 What are relational data models?\nA relational data model is a way of encoding links between multiple tables in a database. A database organized following a relational data model is a relational database. A few of the advantages of using a relational data model are:\n\nEnabling powerful search and filtering\nAbility to handle large, complex data sets\nEnforcing data integrity\nDecreasing errors from redundant updates\n\nRelational data models are used by relational databases (like mySQL, MariaDB, Oracle, or Microsoft Access) to organize tables. However, you don’t have to be using a relational database or handling large and complex data to enjoy the benefits of using a relational data model.\n\n\n9.3.2 Primary and foreign keys\nThe main way in which relational data models encode relationships between different tables is by using keys. Keys are variables whose values uniquely identify observations. For tidy data, where variables and columns are equivalent, a column is a key if it has a different value in each row. This allows us to use keys as unique identifiers that reference particular observations and create links across tables.\nTwo types of keys are common within relational data models:\n\nPrimary Key: chosen key for a table, uniquely identifies each observation in the table,\nForeign Key: reference to a primary key in another table, used to create links between tables.\n\n\n\n9.3.3 Example\nOn our previously normalized data for plants and sites, let’s choose primary keys for these tables and then identify any foreign keys.\nPrimary keys\nFirst, notice that the columns ‘date’, ‘site’ and ‘sp_code’ cannot be primary keys because they have repeated values across rows. The columns ‘sp_height’ and ‘id’ both have different values in each row, so both are candidates for primary keys. However, the decimal values of ‘sp_height’ don’t make it as useful to use it to reference observations. So we chose ‘id’ as the primary key for this table.\nFor the sites table, all three columns could be keys. We chose ‘site’ as the primary key because it is the most succinct and it also allows us to link the sites table with the plants table.\nForeign keys\nThe ‘site’ column is the primary key of that table because it uniquely identifies each row of the table as a unique observation of a site. In the first table, however, the ‘site’ column is a foreign key that references the primary key from the second table. This linkage tells us that the first height measurement for the DAPU observation occurred at the site with the name Taku.\n\n\n\n9.3.4 Surrogate, natural, and compound keys\nIn the plants data table from the previous example, we noticed that ‘id’ and ‘sp_height’ are variables whose values uniquely identify the rows. In other words, ‘id’ and ‘sp_height’ are keys. However, ‘id’ and ‘sp_height’ are very different keys since the values in ‘id’ are “made up”, while ‘sp_height’ has actual observed values. This leads us to the following key types:\n\nSurrogate Key: a key whose values do not exist in the real world,\nNatural Key: a key whose values exist in the real world.\n\nA surrogate key is often simpler, and can be a better choice than a natural key to become the primary key of a data table.\n\nFinally, it can also be the case that a variable is not a key, but by combining it with a second variable we get that the combined values uniquely identify the rows. This is called a\n\nCompound Key: a key that is made up of more than one variable.\n\nFor example, the ‘site’ and ‘sp_code’ columns in the plants table cannot be keys on their own, since each has repeated values. However, when we look at their combined values (1-DAPU, 1-DAMA, 2-DAMA, 2-DAPU) we see each row has a unique value. So ‘site’ and ‘sp_code’ together form a compound key.\n\nThere are different advantages and disadvantages to choosing surrogate, natural, or compound keys as primary keys. You can read more about this in this article.\n\n\n9.3.5 Entity-Relationship models\nAn Entity-Relationship model (E-R model), also known as an E-R diagram, is a way to draw a compact diagram that reflects the structure and relationships of the tables in a relational database. These can be particularly useful for big databases that have many tables and complex relationships between them.\nWe will explain the steps to drawing a simplified E-R model with our previous plants and sites tables.\nStep 1: Identify the entities in the relational database and add each one in a box. In our case, entities are [plants] and [sites], since we are gathering observations about both of these.\n\n\n\n\n\nStep 2: Add variables for each entity and identify keys. Add the variables as a list inside each box. Then, identify the primary and foreign keys in each of the boxes. To visualize this, we have indicated the primary key of each entity in red and any foreign keys in blue.\n\n\n\n\n\nStep 3: Add relationships between entities.\n\nDraw a line between the boxes of any two entities that have a relationship.\nIdentify which box has the primary key of the other as a foreign key. Let’s call the box that has the foreign key [box1] and the other box [box2]. Using the previous diagram we can see that “site” is the primary key of [sites] and appears as a foreign key in [plants]. So [plants] is [box1] and [sites] is [box2].\nAdd a word describing how [box1] is related to [box2] above the line connecting the two boxes. So, for example, we need to describe how [plants] is related to [sites]. The relation is “a plant is located in a site”, so we write “located” above the line indicating the relationship between [plants] and [sites].\n\n\n\n\n\n\nStep 4: Add cardinality to every relationship in the diagram. At this step we want to quantify how many items in an entity are related to another entity. This is easiest if we reuse the description we found in the previous step. For example, “a plant is located in one site”. Then we add the symbol for “one” at the end of the line going from [plants] to [sites].\n\n\n\n\n\nTo finish, we also indicate how many plants are related to a single site. Since “a site has many plants”, we add the symbol for “many” at the end of the line going from [sites] to [plants]\n\n\n\n\n\nThat’s it! The symbols we used at the end of the lines are called ERD “crow’s foot”. You can see all the existing ones together with an example in the next diagram.\n\n\n\n\n\n\n\nNote\n\n\n\nIf you need to produce a publishable E-R model such as the one above, Mermaid is a great option. Read more about how to use this tool to create diagrams here."
  },
  {
    "objectID": "session_09.html#merging-data",
    "href": "session_09.html#merging-data",
    "title": "9  Data Modeling Essentials",
    "section": "9.4 Merging Data",
    "text": "9.4 Merging Data\nFrequently, analysis of data will require merging these separately managed tables back together. There are multiple ways to join the observations in two tables, based on how the rows of one table are merged with the rows of the other. Regardless of the join we will perform, we need to start by identifying the primary key in each table and how these appear as foreign keys in other tables.\nWhen conceptualizing merges, one can think of two tables, one on the left and one on the right.\n\n\n9.4.1 Inner Join\nAn INNER JOIN is when you merge the subset of rows that have matches in both the left table and the right table.\n\n\n\n9.4.2 Left Join\nA LEFT JOIN takes all of the rows from the left table, and merges on the data from matching rows in the right table. Keys that don’t match from the left table are still provided with a missing value (na) from the right table.\n\n\n\n9.4.3 Right Join\nA RIGHT JOIN is the same as a left join, except that all of the rows from the right table are included with matching data from the left, or a missing value. Notice that left and right joins can ultimately be the same depending on the positions of the tables\n\n\n\n9.4.4 Full Outer Join\nFinally, a FULL OUTER JOIN includes all data from all rows in both tables, and includes missing values wherever necessary.\n\nSometimes people represent joins as Venn diagrams, showing which parts of the left and right tables are included in the results for each join. This representation is useful, however, they miss part of the story related to where the missing value comes from in each result.\n\n\n\nImage source: R for Data Science, Wickham & Grolemund.\n\n\nWe suggest this resource for more examples and best practices about joins."
  },
  {
    "objectID": "session_09.html#best-practices-summary",
    "href": "session_09.html#best-practices-summary",
    "title": "9  Data Modeling Essentials",
    "section": "9.5 Best Practices Summary",
    "text": "9.5 Best Practices Summary\nThis is a summary of what we have covered, and some extra advice!\nThe tidy data principles are:\n\nEvery column is a variable.\nEvery row is an observation.\nEvery cell is a single value.\n\nIn normalized data we organize data so that :\n\nWe have separate tables for each type of entity measured\nObservations (rows) are all unique\nEach column represents either an identifying variable or a measured variable\nEach table follows the tidy data principles\n\nCreating relational data models by assigning primary and foreign keys to each table allows us to maintain relationships between separate normalized tables. Choose the primary key for each table based on your understanding of the data and take efficiency into account. Once you choose a column as the primary key, make sure that all the values in that column are there!\nFor a big relational database, an Entity-Relationship model can be an effective way to explain how different tables and their keys are related to each other. If we need to merge tables we can do it using different types of joins."
  },
  {
    "objectID": "session_09.html#more-on-data-management",
    "href": "session_09.html#more-on-data-management",
    "title": "9  Data Modeling Essentials",
    "section": "9.6 More on Data Management",
    "text": "9.6 More on Data Management\nTidy data is one very important step to data management best practices. However there is more to consider. Here we provide some extra advice from a great paper called ‘Some Simple Guidelines for Effective Data Management’:\n\nDesign tables to add rows, not columns\nUse a scripted program (like R!)\nNon-proprietary file formats are preferred (eg: csv, txt)\nKeep a raw version of data\nUse descriptive files and variable names (without spaces!)\nInclude a header line in your tabular data files\nUse plain ASCII text\n\nIn the Cleaning & Wrangling chapter we will cover more best practices for cleaning irregular and missing data and how to implement them using R."
  },
  {
    "objectID": "session_09.html#activity",
    "href": "session_09.html#activity",
    "title": "9  Data Modeling Essentials",
    "section": "9.7 Activity",
    "text": "9.7 Activity"
  },
  {
    "objectID": "session_11.html#learning-objectives",
    "href": "session_11.html#learning-objectives",
    "title": "11  Cleaning and Wrangling Data",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nIntroduce dplyr and tidyr functions to clean and wrangle data for analysis\nLearn about the Split-Apply-Combine strategy and how it applies to data wrangling\nDescribe the difference between wide vs. long table formats and how to convert between them"
  },
  {
    "objectID": "session_11.html#introduction",
    "href": "session_11.html#introduction",
    "title": "11  Cleaning and Wrangling Data",
    "section": "11.1 Introduction",
    "text": "11.1 Introduction\nThe data we get to work with are rarely, if ever, in the format we need to do our analyses. It’s often the case that one package requires data in one format, while another package requires the data to be in another format. To be efficient analysts, we should have good tools for reformatting data for our needs so we can do further work like making plots and fitting models. The dplyr and tidyr R packages provide a fairly complete and extremely powerful set of functions for us to do this reformatting quickly. Learning these tools well will greatly increase your efficiency as an analyst.\nLet’s look at two motivating examples.\n\n\n\n\n\n\nExample 1\n\n\n\nSuppose you have the following data.frame called length_data with data about salmon length and want to calculate the average length per year.\n\n\n\nyear\nlength_cm\n\n\n\n\n1990\n5.673318\n\n\n1991\n3.081224\n\n\n1991\n4.592696\n\n\n1992\n4.381523\n\n\n1992\n5.597777\n\n\n1992\n4.900052\n\n\n\nThe dplyr R library provides a fast and powerful way to do this calculation in a few lines of code:\n\nlength_data %&gt;% \n  group_by(year) %&gt;% \n  summarize(mean_length_cm = mean(length_cm))\n\n\n\n\n\n\n\n\n\nExample 2\n\n\n\nAnother process we often need to do is to “reshape” our data. Consider the following table that is in what we call “wide” format:\n\n\n\nsite\n1990\n1991\n…\n1993\n\n\n\n\ngold\n100\n118\n…\n112\n\n\nlake\n100\n118\n…\n112\n\n\n…\n…\n…\n…\n…\n\n\ndredge\n100\n118\n…\n112\n\n\n\nYou are probably familiar with data in the above format, where values of the variable being observed are spread out across columns. In this example we have a different column per year. This wide format works well for data entry and sometimes works well for analysis but we quickly outgrow it when using R (and know it is not tidy data!). For example, how would you fit a model with year as a predictor variable? In an ideal world, we’d be able to just run lm(length ~ year). But this won’t work on our wide data because lm() needs length and year to be columns in our table.\nThe tidyr package allows us to quickly switch between wide format and long format using the pivot_longer() function:\n\nsite_data %&gt;% \n  pivot_longer(-site, names_to = \"year\", values_to = \"length\")\n\n\n\n\nsite\nyear\nlength\n\n\n\n\ngold\n1990\n101\n\n\nlake\n1990\n104\n\n\ndredge\n1990\n144\n\n\n…\n…\n…\n\n\ndredge\n1993\n145\n\n\n\n\n\nThis lesson will cover examples to learn about the functions you’ll most commonly use from the dplyr and tidyr packages:\n\nCommon dplyr functions\n\n\n\n\n\n\nFunction name\nDescription\n\n\n\n\nmutate()\nCreates modify and deletes columns\n\n\ngroup_by()\nGroups data by one or more variables\n\n\nsummarise()\nSummaries each group down to one row\n\n\nselect()\nKeep or drop columns using their names\n\n\nfilter()\nKeeps rows that matches conditions\n\n\narrange()\norder rows using columns variable\n\n\nrename()\nRename a column\n\n\n\n\nCommon tidyr functions\n\n\n\n\n\n\nFunction name\nDescription\n\n\n\n\npivot_longer()\ntransforms data from a wide to a long format\n\n\npivot_wider()\ntransforms data from a long to a wide format\n\n\nunite()\nUnite multiple columns into one by pasting strings together\n\n\nseparate()\nSeparate a character column into multiple columns with a regular expression or numeric locations"
  },
  {
    "objectID": "session_11.html#data-cleaning-basics",
    "href": "session_11.html#data-cleaning-basics",
    "title": "11  Cleaning and Wrangling Data",
    "section": "11.2 Data cleaning basics",
    "text": "11.2 Data cleaning basics\nTo demonstrate, we’ll be working with a tidied up version of a data set from Alaska Department of Fish & Game containing commercial catch data from 1878-1997. The data set and reference to the original source can be found at its public archive.\n\n\n\n\n\n\nSetup\n\n\n\nFirst, open a new Quarto document. Delete everything below the setup chunk, and add a library chunk that calls dplyr, tidyr, and readr\n\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(readr)\n\n\n\n\n\n\n\n\n\nA note on loading packages\n\n\n\nYou may have noticed the following warning messages pop up when you ran your library chunk.\nAttaching package: ‘dplyr’\n\nThe following objects are masked from ‘package:stats’:\n\n    filter, lag\n\nThe following objects are masked from ‘package:base’:\n\n    intersect, setdiff, setequal, union\nThese are important warnings. They are letting you know that certain functions from the stats and base packages (which are loaded by default when you start R) are masked by different functions with the same name in the dplyr package. It turns out, the order that you load the packages in matters. Since we loaded dplyr after stats, R will assume that if you call filter(), you mean the dplyr version unless you specify otherwise.\nBeing specific about which version of filter(), for example, you call is easy. To explicitly call a function by its unambiguous name, we use the syntax package_name::function_name(...). So, if we wanted to call the stats version of filter() in this Rmarkdown document, I would use the syntax stats::filter(...).\n\n\n\n\n\n\n\n\nNote\n\n\n\nWarnings are important, but we might not want them in our final document. After you have read the packages in, adjust the chunk settings in your library chunk to suppress warnings and messages.\n\n\nNow that we have introduced some data wrangling libraries, let’s get the data that we are going to use for this lesson.\n\n\n\n\n\n\nSetup\n\n\n\n\nGo to KNB Data Package Alaska commercial salmon catches by management region (1886- 1997)\nFind the data file byerlySalmonByRegion.csv. Right click the “Download” button and select “Copy Link Address”\nPaste the copied URL into the read_csv() function\n\nThe code chunk you use to read in the data should look something like this:\n\ncatch_original &lt;- read_csv(\"https://knb.ecoinformatics.org/knb/d1/mn/v2/object/df35b.302.1\")\n\nNote for Windows users: Keep in mind, if you want to replicate this workflow in your local computer you also need to use the url() function here with the argument method = \"libcurl\".\nIt would look like this:\n\ncatch_original &lt;- read.csv(url(\"https://knb.ecoinformatics.org/knb/d1/mn/v2/object/df35b.302.1\", method = \"libcurl\"))\n\n\n\nThis data set is relatively clean and easy to interpret as-is. While it may be clean, it’s in a shape that makes it hard to use for some types of analyses so we’ll want to fix that first.\n\n\n\n\n\n\nExercise\n\n\n\nBefore we get too much further, spend a minute or two outlining your RMarkdown document so that it includes the following sections and steps:\n\nData Sources\n\nRead in the data\nExplore data\n\nClean and Reshape data\n\nRemove unnecessary columns\nCheck column typing\nReshape data"
  },
  {
    "objectID": "session_11.html#data-exploration",
    "href": "session_11.html#data-exploration",
    "title": "11  Cleaning and Wrangling Data",
    "section": "11.3 Data exploration",
    "text": "11.3 Data exploration\nSimilar to what we did in our Intro to Quarto lesson, it is good practice to skim through the data you just read in. Doing so is important to make sure the data is read as you were expecting and to familiarize yourself with the data.\nSome of the basic ways to explore your data are:\n\n## Prints the column names of my data frame\ncolnames(catch_original)\n\n## First 6 lines of the data frame\nhead(catch_original)\n\n## Summary of each column of data\nsummary(catch_original)\n\n## Prints unique values in a column (in this case, the region)\nunique(catch_original$Region)\n\n## Opens data frame in its own tab to see each row and column of the data\nView(catch_original)"
  },
  {
    "objectID": "session_11.html#about-the-pipe-operator",
    "href": "session_11.html#about-the-pipe-operator",
    "title": "11  Cleaning and Wrangling Data",
    "section": "11.4 About the pipe (%>%) operator",
    "text": "11.4 About the pipe (%&gt;%) operator\nBefore we jump into learning tidyr and dplyr, we first need to explain the pipeline operator %&gt;%.\nBoth the tidyr and the dplyr packages use the pipe operator (%&gt;%), which may look unfamiliar. The pipe is a powerful way to efficiently chain together operations. The pipe will take the output of a previous statement, and use it as the input to the next statement.\nSay you want to both filter() out rows of a data set, and select() certain columns.\nInstead of writing:\n\ndf_filtered &lt;- filter(df, ...)\ndf_selected &lt;- select(df_filtered, ...)\n\nYou can write:\n\ndf_cleaned &lt;- df %&gt;% \n    filter(...) %&gt;%\n    select(...)\n\nIf you think of the assignment operator (&lt;-) as reading like “gets”, then the pipe operator would read like “then”.\nSo you might think of the above chunk being translated as:\n\nThe cleaned data frame gets the original data, and then a filter (of the original data), and then a select (of the filtered data).\n\nThe benefits to using pipes are that you don’t have to keep track of (or overwrite) intermediate data frames. The drawbacks are that it can be more difficult to explain the reasoning behind each step, especially when many operations are chained together. It is good to strike a balance between writing efficient code (chaining operations), while ensuring that you are still clearly explaining, both to your future self and others, what you are doing and why you are doing it.\n\n\n\n\n\n\nQuick Tip\n\n\n\nRStudio has a keyboard shortcut for %&gt;%\n\nWindows: Ctrl + Shift + M\nMac: cmd + shift + M"
  },
  {
    "objectID": "session_11.html#selecting-or-removing-columns-using-select",
    "href": "session_11.html#selecting-or-removing-columns-using-select",
    "title": "11  Cleaning and Wrangling Data",
    "section": "11.5 Selecting or removing columns using select()",
    "text": "11.5 Selecting or removing columns using select()\nWe’re ready to go back to our salmon dataset. The first issue is the extra columns All and notesRegCode. Let’s select only the columns we want, and assign this to a variable called catch_data.\n\ncatch_data &lt;- catch_original %&gt;%\n    select(Region, Year, Chinook, Sockeye, Coho, Pink, Chum)\n\nhead(catch_data)\n\n# A tibble: 6 × 7\n  Region  Year Chinook Sockeye  Coho  Pink  Chum\n  &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 SSE     1886 0             5     0     0     0\n2 SSE     1887 0           155     0     0     0\n3 SSE     1888 0           224    16     0     0\n4 SSE     1889 0           182    11    92     0\n5 SSE     1890 0           251    42     0     0\n6 SSE     1891 0           274    24     0     0\n\n\nMuch better!\nThe select() function also allows you to say which columns you don’t want, by passing unquoted column names preceded by minus (-) signs:\n\ncatch_data &lt;- catch_original %&gt;%\n    select(-All,-notesRegCode)"
  },
  {
    "objectID": "session_11.html#quality-check",
    "href": "session_11.html#quality-check",
    "title": "11  Cleaning and Wrangling Data",
    "section": "11.6 Quality check",
    "text": "11.6 Quality check\nNow that we have the data we are interested in using, we should do a little quality check to see that everything seems as expected. One nice way of doing this is the glimpse() function.\n\ndplyr::glimpse(catch_data)\n\nRows: 1,708\nColumns: 7\n$ Region  &lt;chr&gt; \"SSE\", \"SSE\", \"SSE\", \"SSE\", \"SSE\", \"SSE\", \"SSE\", \"SSE\", \"SSE\",…\n$ Year    &lt;dbl&gt; 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 18…\n$ Chinook &lt;chr&gt; \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"3\", \"4\", \"5\", \"9…\n$ Sockeye &lt;dbl&gt; 5, 155, 224, 182, 251, 274, 207, 189, 253, 408, 989, 791, 708,…\n$ Coho    &lt;dbl&gt; 0, 0, 16, 11, 42, 24, 11, 1, 5, 8, 192, 161, 132, 139, 84, 107…\n$ Pink    &lt;dbl&gt; 0, 0, 0, 92, 0, 0, 8, 187, 529, 606, 996, 2218, 673, 1545, 204…\n$ Chum    &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 1, 2, 0, 0, 0, 102, 343…\n\n\n\n\n\n\n\n\nExercise\n\n\n\nExamine the output of the glimpse() function call. Does anything seem amiss with this data set that might warrant fixing?\n\n\nAnswer:\n\nThe Chinook catch data are character class. Let’s fix it using the function mutate() before moving on."
  },
  {
    "objectID": "session_11.html#changing-column-content-using-mutate",
    "href": "session_11.html#changing-column-content-using-mutate",
    "title": "11  Cleaning and Wrangling Data",
    "section": "11.7 Changing column content using mutate()",
    "text": "11.7 Changing column content using mutate()\nWe can use the mutate() function to change a column, or to create a new column. First, let’s try to convert the Chinook catch values to numeric type using the as.numeric() function, and overwrite the old Chinook column.\n\ncatch_clean &lt;- catch_data %&gt;%\n    mutate(Chinook = as.numeric(Chinook))\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `Chinook = as.numeric(Chinook)`.\nCaused by warning:\n! NAs introduced by coercion\n\nhead(catch_clean)\n\n# A tibble: 6 × 7\n  Region  Year Chinook Sockeye  Coho  Pink  Chum\n  &lt;chr&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 SSE     1886       0       5     0     0     0\n2 SSE     1887       0     155     0     0     0\n3 SSE     1888       0     224    16     0     0\n4 SSE     1889       0     182    11    92     0\n5 SSE     1890       0     251    42     0     0\n6 SSE     1891       0     274    24     0     0\n\n\nWe get a warning \"NAs introduced by coercion\" which is R telling us that it couldn’t convert every value to an integer and, for those values it couldn’t convert, it put an NA in its place. This is behavior we commonly experience when cleaning data sets and it’s important to have the skills to deal with it when it comes up.\nTo investigate, let’s isolate the issue. We can find out which values are NAs with a combination of is.na() and which(), and save that to a variable called i.\n\ni &lt;- which(is.na(catch_clean$Chinook))\ni\n\n[1] 401\n\n\nIt looks like there is only one problem row, lets have a look at it in the original data.\n\ncatch_data[i,]\n\n# A tibble: 1 × 7\n  Region  Year Chinook Sockeye  Coho  Pink  Chum\n  &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 GSE     1955 I            66     0     0     1\n\n\nWell that’s odd: The value in catch_thousands is the letter I. It turns out that this data set is from a PDF which was automatically converted into a csv and this value of I is actually a 1.\nLet’s fix it by incorporating the if_else() function to our mutate() call, which will change the value of the Chinook column to 1 if the value is equal to I, then will use as.numeric() to turn the character representations of numbers into numeric typed values.\n\ncatch_clean &lt;- catch_data %&gt;%\n    mutate(Chinook = if_else(condition = Chinook == \"I\", \n                             true = \"1\", \n                             false = Chinook),\n           Chinook = as.integer(Chinook))\n\n##check\ncatch_clean[i, ]\n\n# A tibble: 1 × 7\n  Region  Year Chinook Sockeye  Coho  Pink  Chum\n  &lt;chr&gt;  &lt;dbl&gt;   &lt;int&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 GSE     1955       1      66     0     0     1"
  },
  {
    "objectID": "session_11.html#changing-shape-using-pivot_longer-and-pivot_wider",
    "href": "session_11.html#changing-shape-using-pivot_longer-and-pivot_wider",
    "title": "11  Cleaning and Wrangling Data",
    "section": "11.8 Changing shape using pivot_longer() and pivot_wider()",
    "text": "11.8 Changing shape using pivot_longer() and pivot_wider()\nThe next issue is that the data are in a wide format and we want the data in a long format instead. The function pivot_longer() from the tidyr package helps us do this conversion. If you do not remember all the arguments that go into pivot_longer() you can always call the help page by typing ?pivot_longer in the console.\n\ncatch_long &lt;- catch_clean %&gt;% \n    #pivot longer all columns except Region and Year\n    pivot_longer(\n        cols = -c(Region, Year),\n        names_to = \"species\",\n        values_to = \"catch\"\n    )\n\nhead(catch_long)\n\n# A tibble: 6 × 4\n  Region  Year species catch\n  &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n1 SSE     1886 Chinook     0\n2 SSE     1886 Sockeye     5\n3 SSE     1886 Coho        0\n4 SSE     1886 Pink        0\n5 SSE     1886 Chum        0\n6 SSE     1887 Chinook     0\n\n\nThe syntax we used above for pivot_longer() might be a bit confusing so let’s walk though it.\n\nThe first argument to pivot_longer is the columns over which we are pivoting. You can select these by listing either the names of the columns you do want to pivot, or in this case, the names of the columns you are not pivoting over.\nThe names_to argument takes the name of the column that you are creating from the column names you are pivoting over.\nThe values_to argument takes the name of the column that you are creating from the values in the columns you are pivoting over.\n\nThe opposite of pivot_longer() is the pivot_wider() function. It works in a similar declarative fashion:\n\ncatch_wide &lt;- catch_long %&gt;%\n    pivot_wider(names_from = species,\n                values_from = catch)\n\nhead(catch_wide)\n\n# A tibble: 6 × 7\n  Region  Year Chinook Sockeye  Coho  Pink  Chum\n  &lt;chr&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 SSE     1886       0       5     0     0     0\n2 SSE     1887       0     155     0     0     0\n3 SSE     1888       0     224    16     0     0\n4 SSE     1889       0     182    11    92     0\n5 SSE     1890       0     251    42     0     0\n6 SSE     1891       0     274    24     0     0\n\n\nSame than we did above we can pull up the documentation of the function to remind ourselves what goes in which argument. Type ?pivot_wider in the console."
  },
  {
    "objectID": "session_11.html#renaming-columns-with-rename",
    "href": "session_11.html#renaming-columns-with-rename",
    "title": "11  Cleaning and Wrangling Data",
    "section": "11.9 Renaming columns with rename()",
    "text": "11.9 Renaming columns with rename()\nIf you scan through the data, you may notice the values in the catch column are very small (these are supposed to be annual catches). If we look at the metadata we can see that the catch column is in thousands of fish, so let’s convert it before moving on.\nLet’s first rename the catch column to be called catch_thousands:\n\ncatch_long &lt;- catch_long %&gt;%\n    rename(catch_thousands = catch)\n\nhead(catch_long)\n\n# A tibble: 6 × 4\n  Region  Year species catch_thousands\n  &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;             &lt;dbl&gt;\n1 SSE     1886 Chinook               0\n2 SSE     1886 Sockeye               5\n3 SSE     1886 Coho                  0\n4 SSE     1886 Pink                  0\n5 SSE     1886 Chum                  0\n6 SSE     1887 Chinook               0\n\n\n\n\n\n\n\n\nnames() versus rename()\n\n\n\nMany people use the base R function names() to rename columns, often in combination with column indexing that relies on columns being in a particular order. Column indexing is often also used to select columns instead of the select() function from dplyr. Although these methods work just fine, they do have one major drawback: in most implementations they rely on you knowing exactly the column order your data is in.\nTo illustrate why your knowledge of column order isn’t reliable enough for these operations, considering the following scenario:\nYour colleague emails you letting you know that she has an updated version of the conductivity-temperature-depth data from this year’s research cruise, and sends it along. Excited, you re-run your scripts that use this data for your phytoplankton research. You run the script and suddenly all of your numbers seem off. You spend hours trying to figure out what is going on.\nUnbeknownst to you, your colleagues bought a new sensor this year that measures dissolved oxygen. Because of the new variables in the data set, the column order is different. Your script which previously renamed the fourth column, SAL_PSU to salinity now renames the fourth column, O2_MGpL to salinity. No wonder your results looked so weird, good thing you caught it!\nIf you had written your code so that it doesn’t rely on column order, but instead renames columns using the rename() function, the code would have run just fine (assuming the name of the original salinity column didn’t change, in which case the code would have thrown an error in an obvious way). This is an example of a defensive coding strategy, where you try to anticipate issues before they arise, and write your code in such a way as to keep the issues from happening."
  },
  {
    "objectID": "session_11.html#adding-columns-using-mutate",
    "href": "session_11.html#adding-columns-using-mutate",
    "title": "11  Cleaning and Wrangling Data",
    "section": "11.10 Adding columns using mutate()",
    "text": "11.10 Adding columns using mutate()\nNow let’s use mutate() again to create a new column called catch with units of fish (instead of thousands of fish).\n\ncatch_long &lt;- catch_long %&gt;%\n    mutate(catch = catch_thousands * 1000)\n\nhead(catch_long)\n\nLet’s remove the catch_thousands column for now since we don’t need it. Note that here we have added to the expression we wrote above by adding another function call (mutate) to our expression. This takes advantage of the pipe operator by grouping together a similar set of statements, which all aim to clean up the catch_clean data frame.\n\ncatch_long &lt;- catch_long %&gt;%\n    mutate(catch = catch_thousands * 1000) %&gt;%\n    select(-catch_thousands)\n\nhead(catch_long)\n\n# A tibble: 6 × 4\n  Region  Year species catch\n  &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n1 SSE     1886 Chinook     0\n2 SSE     1886 Sockeye  5000\n3 SSE     1886 Coho        0\n4 SSE     1886 Pink        0\n5 SSE     1886 Chum        0\n6 SSE     1887 Chinook     0\n\n\nWe’re now ready to start analyzing the data."
  },
  {
    "objectID": "session_11.html#summary-statistics-using-group_by-and-summarize",
    "href": "session_11.html#summary-statistics-using-group_by-and-summarize",
    "title": "11  Cleaning and Wrangling Data",
    "section": "11.11 Summary statistics using group_by() and summarize()",
    "text": "11.11 Summary statistics using group_by() and summarize()\nSuppose we are now interested in getting the average catch per region. In our initial data exploration we saw there are 18 regions, we can easily see their names again:\n\nunique(catch_original$Region)\n\n [1] \"SSE\" \"NSE\" \"YAK\" \"GSE\" \"BER\" \"COP\" \"PWS\" \"CKI\" \"BRB\" \"KSK\" \"YUK\" \"NRS\"\n[13] \"KTZ\" \"KOD\" \"CHG\" \"SOP\" \"ALU\" \"NOP\"\n\n\nThink about how we would calculate the average catch per region “by hand”. It would be something like this:\n\nWe start with our table and notice there are multiple regions in the “Regions” column.\nWe split our original table to group all observations from the same region together.\nWe calculate the average catch for each of the groups we form.\nThen we combine the values for average catch per region into a single table.\n\n\n\n\n\n\n\n\nAnalyses like this conform to what is known as the Split-Apply-Combine strategy. This strategy follows the three steps we explained above:\n\nSplit: Split the data into logical groups (e.g., region, species, etc.)\nApply: Calculate some summary statistic on each group (e.g. mean catch by year, number of individuals per species)\nCombine: Combine the statistic calculated on each group back together into a single table\n\nThe dplyr library lets us easily employ the Split-Apply-Combine strategy by using the group_by() and summarize() functions:\n\nmean_region &lt;- catch_long %&gt;%\n    group_by(Region) %&gt;%\n    summarize(mean_catch = mean(catch))\n\nhead(mean_region)\n\n# A tibble: 6 × 2\n  Region mean_catch\n  &lt;chr&gt;       &lt;dbl&gt;\n1 ALU        40384.\n2 BER        16373.\n3 BRB      2709796.\n4 CHG       315487.\n5 CKI       683571.\n6 COP       179223.\n\n\nLet’s see how the previous code implements the Split-Apply-Combine strategy:\n\ngroup_by(Region): this is telling R to split the dataframe and create a group for each different value in the column Region. R just keeps track of the groups, it doesn’t return separate dataframes per region.\nmean(catch): here mean is the function we want to apply to the column catch in each group.\nsummarize(catch = mean(catch)) the function summarize() is used to combine the results of mean(catch) in each group into a single table. The argument mean_catch = mean(catch) indicates that the column having the results of mean(catch) will be named mean_catch.\n\nAnother common use of group_by() followed by summarize() is to count the number of rows in each group. We have to use a special function from dplyr, n().\n\nn_region &lt;- catch_long %&gt;%\n    group_by(Region) %&gt;%\n    summarize(n = n())\n\nhead(n_region)\n\n# A tibble: 6 × 2\n  Region     n\n  &lt;chr&gt;  &lt;int&gt;\n1 ALU      435\n2 BER      510\n3 BRB      570\n4 CHG      550\n5 CKI      525\n6 COP      470\n\n\n\n\n\n\n\n\nTip\n\n\n\nIf you are finding that you are reaching for this combination of group_by(), summarize() and n() a lot, there is a helpful dplyr function count() that accomplishes this in one function!\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\nFind another grouping and statistic to calculate for each group.\nFind out if you can group by multiple variables.\n\n\n\n\n\nAnswer\n## for example:\ncatch_year_sp &lt;- catch_long %&gt;%\n    group_by(Year, species) %&gt;%\n    summarize(total_year = sum(catch, na.rm = T))"
  },
  {
    "objectID": "session_11.html#filtering-rows-using-filter",
    "href": "session_11.html#filtering-rows-using-filter",
    "title": "11  Cleaning and Wrangling Data",
    "section": "11.12 Filtering rows using filter()",
    "text": "11.12 Filtering rows using filter()\nWe use the filter() function to filter our data.frame to rows matching some condition. It’s similar to subset() from base R.\nLet’s go back to our original data.frame and do some filter()ing:\n\nsse_catch &lt;- catch_long %&gt;%\n    filter(Region == \"SSE\")\n\nhead(sse_catch)\n\n# A tibble: 6 × 4\n  Region  Year species catch\n  &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt;\n1 SSE     1886 Chinook     0\n2 SSE     1886 Sockeye  5000\n3 SSE     1886 Coho        0\n4 SSE     1886 Pink        0\n5 SSE     1886 Chum        0\n6 SSE     1887 Chinook     0\n\n\n\n\n\n\n\n\nExercise\n\n\n\n\nFilter to just catches of over one million fish\nFilter to just Chinook from the SSE region\n\n\n\n\n\nAnswer\n## Catches over a million fish\ncatch_million &lt;- catch_long %&gt;%\n    filter(catch &gt; 1000000)\n\n## Chinook from SSE data\nchinook_see &lt;- catch_long %&gt;%\n    filter(Region == \"SSE\",\n           species == \"Chinook\")\n\n## OR\nchinook_see &lt;- catch_long %&gt;%\n    filter(Region == \"SSE\" & species == \"Chinook\")"
  },
  {
    "objectID": "session_11.html#sorting-your-data-using-arrange",
    "href": "session_11.html#sorting-your-data-using-arrange",
    "title": "11  Cleaning and Wrangling Data",
    "section": "11.13 Sorting your data using arrange()",
    "text": "11.13 Sorting your data using arrange()\nThe arrange() function is used to sort the rows of a data.frame. Two common case to use arrange() are:\n\nTo calculate a cumulative sum (with cumsum()) so row order matters\nTo display a table (like in an .Rmd document) in sorted order\n\nLet’s re-calculate mean catch by region, and then arrange() the output by mean catch:\n\nmean_region &lt;- catch_long %&gt;%\n    group_by(Region) %&gt;%\n    summarize(mean_catch = mean(catch)) %&gt;%\n    arrange(mean_catch)\n\nhead(mean_region)\n\n# A tibble: 6 × 2\n  Region mean_catch\n  &lt;chr&gt;       &lt;dbl&gt;\n1 BER        16373.\n2 KTZ        18836.\n3 ALU        40384.\n4 NRS        51503.\n5 KSK        67642.\n6 YUK        68646.\n\n\nThe default sorting order of arrange() is to sort in ascending order. To reverse the sort order, wrap the column name inside the desc() function:\n\nmean_region &lt;- catch_long %&gt;%\n    group_by(Region) %&gt;%\n    summarize(mean_catch = mean(catch)) %&gt;%\n    arrange(desc(mean_catch))\n\nhead(mean_region)\n\n# A tibble: 6 × 2\n  Region mean_catch\n  &lt;chr&gt;       &lt;dbl&gt;\n1 SSE      3184661.\n2 BRB      2709796.\n3 NSE      1825021.\n4 KOD      1528350 \n5 PWS      1419237.\n6 SOP      1110942."
  },
  {
    "objectID": "session_11.html#splitting-a-column-using-separate-and-unite",
    "href": "session_11.html#splitting-a-column-using-separate-and-unite",
    "title": "11  Cleaning and Wrangling Data",
    "section": "11.14 Splitting a column using separate() and unite()",
    "text": "11.14 Splitting a column using separate() and unite()\nThe separate() function and its complement the unite() function allow us to easily split a single column into numerous (or numerous into a single).\nThis can come in really handy when we need to split a column into two pieces by a consistent separator (like a dash).\nLet’s make a new tibble with fake data to illustrate this. Here we have a set of site identification codes with information about the island where the site is (the first 3 letters) and a site number (the 3 numbers). If we want to group and summarize by island, we need a column with just the island information.\n\nsites_df &lt;- tibble(site = c(\"HAW-101\",\n                            \"HAW-103\",\n                            \"OAH-320\",\n                            \"OAH-219\",\n                            \"MAI-039\"))\n\nsites_df %&gt;%\n    separate(site, c(\"island\", \"site_number\"), \"-\")\n\n# A tibble: 5 × 2\n  island site_number\n  &lt;chr&gt;  &lt;chr&gt;      \n1 HAW    101        \n2 HAW    103        \n3 OAH    320        \n4 OAH    219        \n5 MAI    039        \n\n\n\n\n\n\n\n\nExercise\n\n\n\nSplit the city column in the data frame cities_df into city and state_code columns\n\n## create `cities_df`\ncities_df &lt;- data.frame(city = c(\"Juneau AK\",\n                                 \"Sitka AK\",\n                                 \"Anchorage AK\"))\n\n\n\n\n\nAnswer\ncolnames(cities_df)\n\ncities_clean &lt;- cities_df %&gt;%\n    separate(city, c(\"city\", \"state_code\"), \" \")\n\n\nThe unite() function does just the reverse of separate(). If we have a data.frame that contains columns for year, month, and day, we might want to unite these into a single date column.\n\ndates_df &lt;- data.frame(\n    year = c(\"1930\",\n             \"1930\",\n             \"1930\"),\n    month = c(\"12\",\n              \"12\",\n              \"12\"),\n    day = c(\"14\",\n            \"15\",\n            \"16\")\n)\n\ndates_df %&gt;%\n    unite(date, year, month, day, sep = \"-\")\n\n        date\n1 1930-12-14\n2 1930-12-15\n3 1930-12-16"
  },
  {
    "objectID": "session_11.html#now-all-together",
    "href": "session_11.html#now-all-together",
    "title": "11  Cleaning and Wrangling Data",
    "section": "11.15 Now, all together!",
    "text": "11.15 Now, all together!\nWe just ran through the various things we can do with dplyr and tidyr but if you’re wondering how this might look in a real analysis. Let’s look at that now:\n\ncatch_original &lt;- read_csv(url(\"https://knb.ecoinformatics.org/knb/d1/mn/v2/object/df35b.302.1\", \n                               method = \"libcurl\"))\n\nregion_defs &lt;- read_csv(url(\"https://knb.ecoinformatics.org/knb/d1/mn/v2/object/df35b.303.1\", \n                            method = \"libcurl\")) %&gt;% \n    select(code, mgmtArea)\n\nmean_region &lt;- catch_original %&gt;%\n  select(-All, -notesRegCode) %&gt;% \n  mutate(Chinook = ifelse(Chinook == \"I\", 1, Chinook)) %&gt;% \n  mutate(Chinook = as.numeric(Chinook)) %&gt;% \n  pivot_longer(-c(Region, Year), \n               names_to = \"species\", \n               values_to = \"catch\") %&gt;%\n  mutate(catch = catch*1000) %&gt;% \n  group_by(Region) %&gt;% \n  summarize(mean_catch = mean(catch))\n\nhead(mean_region)\n\n# A tibble: 6 × 2\n  Region mean_catch\n  &lt;chr&gt;       &lt;dbl&gt;\n1 ALU        40384.\n2 BER        16373.\n3 BRB      2709796.\n4 CHG       315487.\n5 CKI       683571.\n6 COP       179223.\n\n\nWe have completed our lesson on Cleaning and Wrangling data. Before we break, let’s practice our Github workflow.\n\n\n\n\n\n\nSteps\n\n\n\n\nSave the .Rmd you have been working on for this lesson.\nKnit the R Markdown file. This is a way to test everything in your code is working.\nStage &gt; Commit &gt; Pull &gt; Push"
  },
  {
    "objectID": "session_12.html#learning-objectives",
    "href": "session_12.html#learning-objectives",
    "title": "12  Practice: Cleaning and Wrangling Data",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nPractice using common cleaning and wrangling functions\nPractice joining two data frames\nPractice git and GitHub workflow"
  },
  {
    "objectID": "session_12.html#about-the-data",
    "href": "session_12.html#about-the-data",
    "title": "12  Practice: Cleaning and Wrangling Data",
    "section": "About the data",
    "text": "About the data\nThese exercises will be using data on abundance, size, and trap counts (fishing pressure) of California spiny lobster (Panulirus interruptus) and were collected along the mainland coast of the Santa Barbara Channel by Santa Barbara Coastal LTER researchers (LTER, Reed, and Miller 2022)."
  },
  {
    "objectID": "session_12.html#setup",
    "href": "session_12.html#setup",
    "title": "12  Practice: Cleaning and Wrangling Data",
    "section": "12.1 Setup",
    "text": "12.1 Setup\n\n\n\n\n\n\nGitHub & R setup\n\n\n\n\nCreate a new repository on GitHub. Use the following settings:\n\nAdd a brief description for your new repository. For example: R practice session cleaning and wrangling data during Delta Science Program Synthesis and Training session 1.\nKeep the repository public.\nInitialize the repository with a README file and an R .gitignore template.\n\nClone the repository to a new project in RStudio.\n\n\nNote: We know this is a new, empty repository, so there’s nothing to pull from it. In general, it is a best practice to Pull when you first open a project.\n\n\nCreate a new Quarto file in RStudio. Follow these steps:\n\nAdd a title to the new Quarto file, for example: “Exercise: Explore, Clean, and Wrangle Data”. Add your name to the author field. Press “Create”.\nDelete the default text in the new Quarto file.\nUsing level 2 headers, create an outline for this exercise. Include headers for the following sections: About the data, Setup, Read and explore data, Exercise 1, Exercise 2 , … Exercise 6.\nSave this file with a meaningful name, eg. exercise-clean-wrangle.qmd.\n\nFor this exercise we are going to use the SBC LTER: Reef: Abundance, size and fishing effort for California Spiny Lobster (Panulirus interruptus) data. Navigate to this link and briefly explore the data package. Write a short description of the data in your .qmd file, including a link to the data and the access date.\nAfter saving the file, stage, commit, write a commit message, pull, and push this file to the remote repository (on GitHub).\n\n\n\n\n\n\n\n\n\nRead in data\n\n\n\n\nUnder the Setup section, load the following libraries in a new code chunk.\n\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(tidyr)\n\n\nRead in the data.\n\nCreate a new code chunk under the Read and explore ata header.\nNavigate to the data package site and copy the the URL to access the Time-series of lobster abundance and size data. To copy the URL: hover over the Download button –&gt; right click –&gt; “Copy Link Address”.\nRead in the data from the URL using the read_csv function and store it as lobster_abundance.\nRead in the Time-series of lobster trap buoy counts data as lobster_traps by repeating setps b and c. \n\n\n\n# Read in data\nlobster_abundance &lt;- read_csv(\"https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-sbc.77.8&entityid=f32823fba432f58f66c06b589b7efac6\")\n\nlobster_traps &lt;- read_csv(\"https://portal.edirepository.org/nis/dataviewer?packageid=knb-lter-sbc.77.8&entityid=66dd61c75bda17c23a3bce458c56ed84\")\n\n\nLook at each data frame. Take a minute to explore their data structure, find out which data types are in the data frame, or use a function to get a high-level summary of the data.\nUse the Git workflow: Stage &gt; Commit &gt; Pull &gt; Push."
  },
  {
    "objectID": "session_12.html#convert-missing-values-using-mutate-and-na_if",
    "href": "session_12.html#convert-missing-values-using-mutate-and-na_if",
    "title": "12  Practice: Cleaning and Wrangling Data",
    "section": "12.2 Convert missing values using mutate() and na_if()",
    "text": "12.2 Convert missing values using mutate() and na_if()\n\n\n\n\n\n\nExercise 1: lobster_abundance\n\n\n\nThe variable SIZE_MM uses -99999 as the code for missing values (see metadata). This has the potential to cause conflicts with our analyses. Modify the data following these steps:\n\nVerify the SIZE_MM variable contains -99999 values using unique().\nConvert every -99999 value to an NA value using mutate() and na_if(). Look up the help page to see how to use na_if().\nCheck your output data using unique().\n\n\n\n\n\nCode\nlobster_abundance &lt;- lobster_abundance %&gt;% \n    mutate(SIZE_MM = na_if(SIZE_MM, -99999))"
  },
  {
    "objectID": "session_12.html#filter-practice",
    "href": "session_12.html#filter-practice",
    "title": "12  Practice: Cleaning and Wrangling Data",
    "section": "12.3 filter() practice",
    "text": "12.3 filter() practice\n\n\n\n\n\n\nExercise 2: lobster_abundance\n\n\n\nCreate a subset with the data for the lobsters at Arroyo Quemado (AQUE) that have a carapace length greater than 70 mm.\n\n\n\n\nCode\naque_70mm &lt;- lobster_abundance %&gt;% \n    filter(SITE == \"AQUE\" & SIZE_MM &gt;= 70)\n\n\n\n\n\n\n\n\nExercise 3: lobster_traps\n\n\n\nCreate a subset with the traps’ information at all sites where abundance data is not NA. Note that you first have to identify which are these sites.\nHINT: use %in%.\n\n\n\n\nCode\n## Create a vector with unique sites in lobster_abundance\nabundance_sites &lt;- unique(lobster_abundance$SITE)\n\n## Filter sites in vector above\ntraps_subset &lt;- lobster_traps %&gt;% \n    filter(SITE %in% abundance_sites)\n\n\n\n\n\n\n\n\nSave your work and use Git\n\n\n\nDon’t forget the Git workflow! After you’ve completed the exercises or reached a significant stopping point, use the workflow: Stage &gt; Commit &gt; Pull &gt; Push."
  },
  {
    "objectID": "session_12.html#calculate-totals-by-site-and-year",
    "href": "session_12.html#calculate-totals-by-site-and-year",
    "title": "12  Practice: Cleaning and Wrangling Data",
    "section": "12.4 Calculate totals by site and year",
    "text": "12.4 Calculate totals by site and year\n\n\n\n\n\n\nExercise 4: lobster_abundance and traps_subset\n\n\n\nFor each data frame, calculate the total count and total traps by site and year (i.e. for every combination of site and year). Store these summary statistics in separate data frames.\nHINT: use group_by() and summarize().\n\n\n\n\nCode\ntotal_abundance &lt;- lobster_abundance %&gt;% \n    group_by(SITE, YEAR) %&gt;% \n    summarize(total_lobsters = sum(COUNT, na.rm = T))\n\n\ntotal_traps &lt;- traps_subset %&gt;% \n    group_by(SITE, YEAR) %&gt;% \n    summarize(total_traps = sum(TRAPS, na.rm = T))"
  },
  {
    "objectID": "session_12.html#joining-two-data-frames",
    "href": "session_12.html#joining-two-data-frames",
    "title": "12  Practice: Cleaning and Wrangling Data",
    "section": "12.5 Joining two data frames",
    "text": "12.5 Joining two data frames\n\n\n\n\n\n\nExercise 5: total_abundance and total_traps\n\n\n\nUse one of the join_ functions to get an output data frame with the following columns: SITE, YEAR, total_lobsters, total_traps.\nDiscuss with your neighbor how the output data frame varies when you do a left_join() or a full_join(). What happens when you do an inner_join()?\nDo you notice anything not right in the outcome data frame? We’ll get to it in exercise 7.\n\n\n\n\nCode\nabundance_traps &lt;- total_abundance %&gt;% \n  left_join(total_traps, by = c(\"SITE\", \"YEAR\"))\n\n##  Or\n\nabundance_traps &lt;- total_abundance %&gt;% \n  full_join(total_traps, by = c(\"SITE\", \"YEAR\"))\n\n## Or\n\nabundance_traps &lt;- total_abundance %&gt;% \n  inner_join(total_traps, by = c(\"SITE\", \"YEAR\"))"
  },
  {
    "objectID": "session_12.html#adding-a-new-column",
    "href": "session_12.html#adding-a-new-column",
    "title": "12  Practice: Cleaning and Wrangling Data",
    "section": "12.6 Adding a new column",
    "text": "12.6 Adding a new column\n\n\n\n\n\n\nExercise 6\n\n\n\nThe sites IVEE and NAPL are marine protected areas (MPAs). Read the documentation about the case_when() function and use it to add this designation to your data set.\nHINT: Notice you will have to create a new column with the MPA designation. What function have you previously used to create new columns?\n\n\n\n\nCode\nlobster_mpa &lt;- abundance_traps %&gt;% \n    mutate(DESIGNATION = case_when(\n    SITE %in% c(\"IVEE\", \"NAPL\") ~ \"MPA\",\n    SITE %in% c(\"AQUE\", \"CARP\", \"MOHK\") ~ \"not MPA\"))\n\n\n\n\n\n\n\n\nSave your work and use Git\n\n\n\nDon’t forget the Git workflow! After you’ve completed the exercises or reached a significant stopping point, use the workflow: Stage &gt; Commit &gt; Pull &gt; Push."
  },
  {
    "objectID": "session_12.html#bonus",
    "href": "session_12.html#bonus",
    "title": "12  Practice: Cleaning and Wrangling Data",
    "section": "12.7 Bonus",
    "text": "12.7 Bonus\n\n\n\n\n\n\nExercise 7\n\n\n\nWhat would you do to fix the issues with the values in the total_traps column? Find the root of the issue, modify the dataset to solve it, and discuss with your neighbor where in your script you would include this step.\n\n\n\n\nCode\n# Replace -99999 values for NAs at the beginning of the script, \n# similar to what we did in question 1 but for lobster_traps data frame. \n# Then re run all the other steps.\n\nlobster_traps &lt;- lobster_traps %&gt;% \n    mutate(TRAPS = na_if(TRAPS, -99999))\n\n\n\n\n\n\nLTER, Santa Barbara Coastal, Daniel C Reed, and Robert J Miller. 2022. “SBC LTER: Reef: Abundance, Size and Fishing Effort for California Spiny Lobster (Panulirus Interruptus), Ongoing Since 2012.” Environmental Data Initiative. https://doi.org/10.6073/PASTA/25AA371650A671BAFAD64DD25A39EE18."
  },
  {
    "objectID": "session_13.html#synthesis-development",
    "href": "session_13.html#synthesis-development",
    "title": "13  Hands on Synthesis",
    "section": "13.1 Synthesis Development",
    "text": "13.1 Synthesis Development\nThis is a hands-on facilitated session to guide the development of synthesis questions."
  },
  {
    "objectID": "session_14.html#learning-objectives",
    "href": "session_14.html#learning-objectives",
    "title": "14  Creating Functions in R",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nLearn why we should write code in small functions\nWrite code for one or more functions\nDocument functions to improve understanding and code communication"
  },
  {
    "objectID": "session_14.html#creating-r-functions",
    "href": "session_14.html#creating-r-functions",
    "title": "14  Creating Functions in R",
    "section": "14.1 Creating R Functions",
    "text": "14.1 Creating R Functions\nMany people write R code as a single, continuous stream of commands, often drawn from the R Console itself and simply pasted into a script. While any script brings benefits over non-scripted solutions, there are advantages to breaking code into small, reusable modules. This is the role of a function in R. In this lesson, we will review the advantages of coding with functions, practice by creating some functions and show how to call them, and then do some exercises to build other simple functions.\n\n14.1.1 Why functions?\nIn a word:\n\nDRY: Don’t Repeat Yourself\n\nBy creating small functions that only one logical task and do it well, we quickly gain:\n\nImproved understanding\nReuse via decomposing tasks into bite-sized chunks\nImproved error testing\n\n\nTemperature conversion\nImagine you have a bunch of data measured in Fahrenheit and you want to convert that for analytical purposes to Celsius. You might have an R script that does this for you.\n\nairtemps &lt;- c(212, 30.3, 78, 32)\ncelsius1 &lt;- (airtemps[1]-32)*5/9\ncelsius2 &lt;- (airtemps[2]-32)*5/9\ncelsius3 &lt;- (airtemps[3]-32)*5/9\n\nNote the duplicated code, where the same formula is repeated three times. This code would be both more compact and more reliable if we didn’t repeat ourselves.\n\n\nCreating a function\nFunctions in R are a mechanism to process some input and return a value. Similarly to other variables, functions can be assigned to a variable so that they can be used throughout code by reference. To create a function in R, you use the function function (so meta!) and assign its result to a variable. Let’s create a function that calculates celsius temperature outputs from fahrenheit temperature inputs.\n\nfahr_to_celsius &lt;- function(fahr) {\n  celsius &lt;- (fahr-32)*5/9\n  return(celsius)\n}\n\nBy running this code, we have created a function and stored it in R’s global environment. The fahr argument to the function function indicates that the function we are creating takes a single parameter (the temperature in fahrenheit), and the return statement indicates that the function should return the value in the celsius variable that was calculated inside the function. Let’s use it, and check if we got the same value as before:\n\ncelsius4 &lt;- fahr_to_celsius(airtemps[1])\ncelsius4\n\n[1] 100\n\ncelsius1 == celsius4\n\n[1] TRUE\n\n\nExcellent. So now we have a conversion function we can use. Note that, because most operations in R can take multiple types as inputs, we can also pass the original vector of airtemps, and calculate all of the results at once:\n\ncelsius &lt;- fahr_to_celsius(airtemps)\ncelsius\n\n[1] 100.0000000  -0.9444444  25.5555556   0.0000000\n\n\nThis takes a vector of temperatures in fahrenheit, and returns a vector of temperatures in celsius.\n\n\nChallenge\nNow, create a function named celsius_to_fahr that does the reverse, it takes temperature data in celsius as input, and returns the data converted to fahrenheit. Then use that formula to convert the celsius vector back into a vector of fahrenheit values, and compare it to the original airtemps vector to ensure that your answers are correct. Hint: the formula for C to F conversions is celsius*9/5 + 32.\n\n# Your code goes here\n\nDid you encounter any issues with rounding or precision?\n\n\n\n14.1.2 Documenting R functions\nFunctions need documentation so that we can communicate what they do, and why. The roxygen2 package provides a simple means to document your functions so that you can explain what the function does, the assumptions about the input values, a description of the value that is returned, and the rationale for decisions made about implementation.\nDocumentation in ROxygen is placed immediately before the function definition, and is indicated by a special comment line that always starts with the characters #'. Here’s a documented version of a function:\n\n#' Convert temperature data from Fahrenheit to Celsius\n#'\n#' @param fahr Temperature data in degrees Fahrenheit to be converted\n#' @return temperature value in degrees Celsius\n#' @keywords conversion\n#' @export\n#' @examples\n#' fahr_to_celsius(32)\n#' fahr_to_celsius(c(32, 212, 72))\nfahr_to_celsius &lt;- function(fahr) {\n  celsius &lt;- (fahr-32)*5/9\n  return(celsius)\n}\n\nNote the use of the @param keyword to define the expectations of input data, and the @return keyword for defining the value that is returned from the function. The @examples function is useful as a reminder as to how to use the function. Finally, the @export keyword indicates that, if this function were added to a package, then the function should be available to other code and packages to utilize.\n\n\n14.1.3 Summary\n\nFunctions are useful to reduce redundancy, reuse code, and reduce errors\nBuild functions with the function function\nDocument functions with roxygen2 comments\n\n\nSpoiler – the exercise answered\nDon’t peek until you write your own…\n\n# Your code goes here\ncelsius_to_fahr &lt;- function(celsius) {\n    fahr &lt;- celsius*9/5 + 32\n    return(fahr)\n}\n\nresult &lt;- celsius_to_fahr(celsius)\nairtemps == result\n\n[1] TRUE TRUE TRUE TRUE\n\n\n\n\n\n14.1.4 Examples: Minimizing work with functions\nFunctions can of course be as simple or complex as needed. They can be be very effective in repeatedly performing calculations, or for bundling a group of commands that are used on many different input data sources. For example, we might create a simple function that takes fahrenheit temperatures as input, and calculates both celsius and Kelvin temperatures. All three values are then returned in a list, making it very easy to create a comparison table among the three scales.\n\nconvert_temps &lt;- function(fahr) {\n  celsius &lt;- (fahr-32)*5/9\n  kelvin &lt;- celsius + 273.15\n  return(list(fahr=fahr, celsius=celsius, kelvin=kelvin))\n}\n\ntemps_df &lt;- data.frame(convert_temps(seq(-100,100,10)))\n\n\n\n\n\n\n\n\nOnce we have a dataset like that, we might want to plot it. One thing that we do repeatedly is set a consistent set of display elements for creating graphs and plots. By using a function to create a custom ggplot theme, we can enable to keep key parts of the formatting flexible. FOr example, in the custom_theme function, we provide a base_size argument that defaults to using a font size of 9 points. Because it has a default set, it can safely be omitted. But if it is provided, then that value is used to set the base font size for the plot.\n\ncustom_theme &lt;- function(base_size = 9) {\n    ggplot2::theme(\n      axis.ticks       = ggplot2::element_blank(),\n      text             = ggplot2::element_text(family = 'Helvetica', color = 'gray30', size = base_size),\n      plot.title       = ggplot2::element_text(size = ggplot2::rel(1.25), hjust = 0.5, face = 'bold'),\n      panel.background = ggplot2::element_blank(),\n      legend.position  = 'right',\n      panel.border     = ggplot2::element_blank(),\n      panel.grid.minor = ggplot2::element_blank(),\n      panel.grid.major = ggplot2::element_line(colour = 'grey90', size = .25),\n      legend.key       = ggplot2::element_rect(colour = NA, fill = NA),\n      axis.line        = ggplot2::element_blank()\n      )\n}\n\nlibrary(ggplot2)\n\nggplot(temps_df, mapping=aes(x=fahr, y=celsius, color=kelvin)) +\n    geom_point() +\n    custom_theme(10)\n\nWarning: The `size` argument of `element_line()` is deprecated as of ggplot2 3.4.0.\nℹ Please use the `linewidth` argument instead.\n\n\n\n\n\nIn this case, we set the font size to 10, and plotted the air temperatures. The custom_theme function can be used anywhere that one needs to consistently format a plot.\nBut we can go further. One can wrap the entire call to ggplot in a function, enabling one to create many plots of the same type with a consistent structure. For example, we can create a scatterplot function that takes a data frame as input, along with a point_size for the points on the plot, and a font_size for the text.\n\nscatterplot &lt;- function(df, point_size = 2, font_size=9) {\n  ggplot(df, mapping=aes(x=fahr, y=celsius, color=kelvin)) +\n    geom_point(size=point_size) +\n    custom_theme(font_size)\n}\n\nCalling that let’s us, in a single line of code, create a highly customized plot but maintain flexibiity via the arguments passed in to the function. Let’s set the point size to 3 and font to 16 to make the plot more legible.\n\nscatterplot(temps_df, point_size=3, font_size = 16)\n\n\n\n\nOnce these functions are set up, all of the plots built with them can be reformatted by changing the settings in just the functions, whether they were used to create 1, 10, or 100 plots."
  },
  {
    "objectID": "session_15.html",
    "href": "session_15.html",
    "title": "15  Creating R Packages",
    "section": "",
    "text": "15.0.1 Learning Objectives\nIn this lesson, you will learn:\n\nThe advantages of using R packages for organizing code\nSimple techniques for creating R packages\nApproaches to documenting code in packages\n\n\n\n15.0.2 Why packages?\nMost R users are familiar with loading and utilizing packages in their work. And they know how rich CRAN is in providing for many conceivable needs. Most people have never created a package for their own work, and most think the process is too complicated. Really it’s pretty straighforward and super useful in your personal work. Creating packages serves two main use cases:\n\nMechanism to redistribute reusable code (even if just for yourself)\nMechanism to reproducibly document analysis and models and their results\n\nEven if you don’t plan on writing a package with such broad appeal such as, say, ggplot2 or dplyr, you still might consider creating a package to contain:\n\nUseful utility functions you write i.e. a Personal Package. Having a place to put these functions makes it much easier to find and use them later.\nA set of shared routines for your lab or research group, making it easier to remain consistent within your team and also to save time.\nThe analysis accompanying a thesis or manuscript, making it all that much easier for others to reproduce your results.\n\nThe usethis, devtools and roxygen2 packages make creating and maintining a package to be a straightforward experience.\n\n\n15.0.3 Install and load packages\n\nlibrary(devtools)\nlibrary(usethis)\nlibrary(roxygen2)\n\n\n\n15.0.4 Create a basic package\nThanks to the great usethis package, it only takes one function call to create the skeleton of an R package using create_package(). Which eliminates pretty much all reasons for procrastination. To create a package called mytools, all you do is:\n\nsetwd('..')\ncreate_package(\"mytools\")\n\n✔ Setting active project to '/Users/jones/development/mytools'\n✔ Creating 'R/'\n✔ Creating 'man/'\n✔ Writing 'DESCRIPTION'\n✔ Writing 'NAMESPACE'\n✔ Writing 'mytools.Rproj'\n✔ Adding '.Rproj.user' to '.gitignore'\n✔ Adding '^mytools\\\\.Rproj$', '^\\\\.Rproj\\\\.user$' to '.Rbuildignore'\n✔ Opening new project 'mytools' in RStudio\nNote that this will open a new project (mytools) and a new session in RStudio server.\nThe create_package function created a top-level directory structure, including a number of critical files under the standard R package structure. The most important of which is the DESCRIPTION file, which provides metadata about your package. Edit the DESCRIPTION file to provide reasonable values for each of the fields, including your own contact information.\nInformation about choosing a LICENSE is provided in the Extending R documentation. The DESCRIPTION file expects the license to be chose from a predefined list, but you can use it’s various utility methods for setting a specific license file, such as the Apacxhe 2 license:\n\nusethis::use_apache_license()\n\n✔ Setting License field in DESCRIPTION to 'Apache License (&gt;= 2.0)'\n✔ Writing 'LICENSE.md'\n✔ Adding '^LICENSE\\\\.md$' to '.Rbuildignore'\nOnce your license has been chosen, and you’ve edited your DESCRIPTION file with your contact information, a title, and a description, it will look like this:\n\nPackage: mytools\nTitle: Utility Functions Created by Matt Jones\nVersion: 0.1\nAuthors@R: \"Matthew Jones &lt;jones@nceas.ucsb.edu&gt; [aut, cre]\"\nDescription: Package mytools contains a suite of utility functions useful whenever I need stuff to get done.\nDepends: R (&gt;= 3.5.0)\nLicense: Apache License (&gt;= 2.0)\nLazyData: true\n\n\n\n15.0.5 Add your code\nThe skeleton package created contains a directory R which should contain your source files. Add your functions and classes in files to this directory, attempting to choose names that don’t conflict with existing packages. For example, you might add a file cutsom_theme that contains a function custom_theme() that you might want to reuse. The usethis::use_r() function will help set up you files in the right places. For example, running:\n\nusethis::use_r(\"custom_theme\")\n\n● Modify 'R/custom_theme'\ncreates the file R/custom_theme, which you can then modify to add the implementation of the following function from the functions lesson:\n\ncustom_theme &lt;- function(base_size = 9) {\n    ggplot2::theme(\n      axis.ticks       = ggplot2::element_blank(),\n      text             = ggplot2::element_text(family = 'Helvetica', color = 'gray30', size = base_size),\n      plot.title       = ggplot2::element_text(size = ggplot2::rel(1.25), hjust = 0.5, face = 'bold'),\n      panel.background = ggplot2::element_blank(),\n      legend.position  = 'right',\n      panel.border     = ggplot2::element_blank(),\n      panel.grid.minor = ggplot2::element_blank(),\n      panel.grid.major = ggplot2::element_line(colour = 'grey90', size = .25),\n      legend.key       = ggplot2::element_rect(colour = NA, fill = NA),\n      axis.line        = ggplot2::element_blank()\n      )\n}\n\nIf your R code depends on functions from another package, then you must declare so in the Imports list in the DESCRIPTION file for your package. In our example above, we depend on the ggplot2 package, and so we need to list it as a dependency. Once again, usethis provides a handy helper method:\n\nusethis::use_package(\"ggplot2\")\n\n✔ Adding 'ggplot2' to Imports field in DESCRIPTION\n● Refer to functions with `devtools::fun()`\n\n\n15.0.6 Add documentation\nYou should provide documentation for each of your functions and classes. This is done in the roxygen2 approach of providing embedded comments in the source code files, which are in turn converted into manual pages and other R documentation artifacts. Be sure to define the overall purpose of the function, and each of its parameters.\n\n#' A function set a custom ggplot theme.\n#'\n#' This function sets ggplot theme elements that I like, with the ability to change\n#' the base size of the text.\n#'\n#' @param base_size Base size of plot text\n#'\n#' @keywords plotting\n#'\n#' @export\n#'\n#' @examples\n#' library(ggplot2)\n#'\n#' ggplot(iris, aes(Sepal.Length, Sepal.Width)) +\n#'     geom_point() +\n#'     custom_theme(base_size = 10)\n#'\ncustom_theme &lt;- function(base_size = 9) {\n    ggplot2::theme(\n        axis.ticks       = ggplot2::element_blank(),\n        text             = ggplot2::element_text(family = 'Helvetica', color = 'gray30', size = base_size),\n        plot.title       = ggplot2::element_text(size = ggplot2::rel(1.25), hjust = 0.5, face = 'bold'),\n        panel.background = ggplot2::element_blank(),\n        legend.position  = 'right',\n        panel.border     = ggplot2::element_blank(),\n        panel.grid.minor = ggplot2::element_blank(),\n        panel.grid.major = ggplot2::element_line(colour = 'grey90', size = .25),\n        legend.key       = ggplot2::element_rect(colour = NA, fill = NA),\n        axis.line        = ggplot2::element_blank()\n    )\n}\n\nOnce your files are documented, you can then process the documentation using the document() function to generate the appropriate .Rd files that your package needs.\n\ndevtools::document()\n\nUpdating mytools documentation\nUpdating roxygen version in /Users/jones/development/mytools/DESCRIPTION\nWriting NAMESPACE\nLoading mytools\nWriting NAMESPACE\nWriting custom_theme.Rd\nThat’s really it. You now have a package that you can check() and install() and release(). See below for these helper utilities.\n\n\n15.0.7 Test your package\nYou can test your code using the tetsthat testing framework. The ussethis::use_testthat() function will set up your package for testing, and then you can use the use_test() function to setup individual test files. For example, in the functions lesson we created some tests for our fahr_to_celsius functions but ran them line by line in the console.\nFirst, lets add that function to our package. Run the use_r function in the console:\n\nusethis::use_r(\"fahr_to_celsius\")\n\nThen copy the function and documentation into the R script that opens and save the file.\n\n#' Convert temperature data from Fahrenheit to Celsius\n#'\n#' @param fahr Temperature data in degrees Fahrenheit to be converted\n#' @return temperature value in degrees Celsius\n#' @keywords conversion\n#' @export\n#' @examples\n#' fahr_to_celsius(32)\n#' fahr_to_celsius(c(32, 212, 72))\nfahr_to_celsius &lt;- function(fahr) {\n  celsius &lt;- (fahr-32)*5/9\n  return(celsius)\n}\n\nNow, set up your package for testing:\n\nusethis::use_testthat()\n\n✔ Adding 'testthat' to Suggests field in DESCRIPTION\n✔ Creating 'tests/testthat/'\n✔ Writing 'tests/testthat.R'\nThen write a test for fahr_to_celsius:\n\nusethis::use_test(\"fahr_to_celsius\")\n\n✔ Writing 'tests/testthat/test-fahr_to_celsius.R'\n● Modify 'tests/testthat/test-fahr_to_celsius.R'\nYou can now add tests to the test-fahr_to_celsius.R, and you can run all of the tests using devtools::test(). For example, if you add a test to the test-fahr_to_celsius.R file:\n\ntest_that(\"fahr_to_celsius works\", {\n  expect_equal(fahr_to_celsius(32), 0)\n  expect_equal(fahr_to_celsius(212), 100)\n})\n\nThen you can run the tests to be sure all of your functions are working using devtools::test():\n\ndevtools::test()\n\nLoading mytools\nTesting mytools\n✔ | OK F W S | Context\n✔ |  2       | test-fahr_to_celsius [0.1 s]\n\n══ Results ════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════\nDuration: 0.1 s\n\nOK:       2\nFailed:   0\nWarnings: 0\nSkipped:  0\nYay, all tests passed!\n\n\n15.0.8 Checking and installing your package\nNow that your package is built, you can check it for consistency and completeness using check(), and then you can install it locally using install(), which needs to be run from the parent directory of your module.\n\ndevtools::check()\ndevtools::install()\n\nYour package is now available for use in your local environment.\n\n\n15.0.9 Sharing and releasing your package\nThe simplest way to share your package with others is to upload it to a GitHub repository, which allows others to install your package using the install_github('mytools','github_username') function from devtools.\nIf your package might be broadly useful, also consider releasing it to CRAN, using the release() method from `devtools(). Releasing a package to CRAN requires a significant amoutn of work to ensure it follows the standards set by the R community, but it is entirely tractable and a valuable contribution to the science community. If you are considering releasing a package more broadly, you may find that the supportive community at ROpenSci provides incredible help and valuable feeback through their onboarding process.\n\nChallenge\nAdd the other temperature conversion functions with full documentation to your package, write tests to ensure the functions work properly, and then document(), check(), and install() the new version of the package. Don’t forget to update the version number before you install!\n\n\n\n15.0.10 More reading\n\nHadley Wickham’s awesome book: R Packages\nThomas Westlake’s blog Writing an R package from scratch"
  },
  {
    "objectID": "session_16.html#learning-objectives",
    "href": "session_16.html#learning-objectives",
    "title": "16  FAIR and CARE principles",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nIntroduce FAIR and CARE principles and the value it provides to data\nProvide a FAIR and CARE lens that can be applied to your data-focused work\nEvaluate the FAIRness and CAREness of your work and the work of others"
  },
  {
    "objectID": "session_16.html#the-fair-and-care-principles",
    "href": "session_16.html#the-fair-and-care-principles",
    "title": "16  FAIR and CARE principles",
    "section": "16.1 The FAIR and CARE Principles",
    "text": "16.1 The FAIR and CARE Principles\n\n\n\nSource: Global Indigenous Data Alliance\n\n\nThe idea behind these principles is to increase access and usage of complex and large datasets for innovation, discovery, and decision-making. This means making data available to machines, researchers, Indigenous communities, policy makers, and more.\nWith the need to improve the infrastructure supporting the reuse of data, a group of diverse stakeholders from academia, funding agencies, publishers and industry came together to jointly endorse measurable guidelines that enhance the reusability of data (Wilkinson et al. (2016)). These guidelines became what we now know as the FAIR Data Principles.\nFollowing the discussion about FAIR and incorporating activities and feedback from the Indigenous Data Sovereignty network, the Global Indigenous Data Alliance developed the CARE principles (Carroll et al. (2021)). The CARE principles for Indigenous Data Governance complement the more data-centric approach of the FAIR principles, introducing social responsibility to open data management practices.\nTogether, these two principle encourage us to push open and other data movements to consider both people and purpose in their advocacy and pursuits. The goal is that researchers, stewards, and any users of data will be FAIR and CARE (Carroll et al. (2020)).\n\n16.1.1 What is FAIR?\nWith the rise of open science and more accessible data, it is becoming increasingly important to address accessibility and openness in multiple ways. The FAIR principles focuses on how to prepare your data so that it can be reused by others (versus just open access of research outputs). In 2016, the data stewardship community published principles surrounding best practices for open data management, including FAIR. FAIR stands for Findable, Accessible, Interoperable, and Reproducible. It is best to think about FAIR as a set of comprehensive standards for you to use while curating your data. And each principle of FAIR can be translated into a set of actions you can take during the entire lifecycle of research data management.\n\n\n\nSource: Fair Teaching Handbook\n\n\n\n\n\n\n\n\n\nFAIR\nDefinition\n\n\n\n\n(F) Findable\nMetadata and data should be easy to find for both humans and computers.\n\n\n(A) Accessible\nOnce someone finds the required data, they need to know how the data can be accessed.\n\n\n(I) Interoperable\nThe data needs to be easily integrated with other data for analysis, storage, and processing.\n\n\n(R) Reusable\nData should be well-described so they can be reused and replicated in different settings.\n\n\n\n\n\n16.1.2 FAIR Principles in Practice\nThis is not an exhaustive list of actions for applying FAIR Principles to your research, but these are important big picture concepts you should always keep in mind. We’ll be going through the resources linked below so that you know how to use them in your own work.\n\nIt’s all about the metadata. To make your data and research as findable and as accessible as possible, it’s crucial that you are providing rich metadata. This includes, using a field-specific metadata standard (i.e. EML or Ecological Metadata Language for earth and environmental sciences), adding a globally unique identifier (i.e. a Digital Object Identifier) to your datasets, and more. As discussed in a previous lesson, quality metadata goes a long way in making your data FAIR. One tool to help implement FAIR principles to non-FAIR data is the FAIRification process. This workflow was developed by GoFAIR, a self-governed initiative that aims to help implement the FAIR data principles.\nAssess the FAIRness of your research. The FAIR Principles are a lens to apply to your work. And it’s important to ask yourself questions about finding and accessing your data, about how machine-readable your datasets and metadata are, and how reusable it is throughout the entirety of your project. This means you should be re-evaluating the FAIRness of your work over and over again. One way to check the FAIRness of your work, is to use tools like FAIR-Aware and the FAIR Data Maturity Model. These tools are self-assessments and can be thought of as a checklists for FAIR and will provide guidance if you’re missing anything.\nMake FAIR decisions during the planning process. You can ensure FAIR Principles are going to implemented in your work by thinking about it and making FAIR decisions early on and throughout the data life cycle. As you document your data always keep in mind the FAIR lense.\n\n\n\n16.1.3 What is CARE?\nThe CARE Principles for Indigenous Data Governance were developed by the International Indigenous Data Sovereignty Interest Group in consultation with Indigenous Peoples, scholars, non-profit organizations, and governments (Carroll et al. (2020)). They address concerns related to the people and purpose of data. It advocates for greater Indigenous control and oversight in order to share data on Indigenous Peoples’ terms. These principles are people and purpose-oriented, reflecting the crucial role data have in advancing Indigenous innovation and self-determination. CARE stands for Collective benefits, Authority control, Responsibility and Ethics. It details that the use of Indigenous data should result in tangible benefits for Indigenous collectives through inclusive development and innovation, improved governance and citizen engagement, and result in equitable outcomes.\n\n\n\nSource: Carroll, S.R., et al, 2020. The CARE Principles for Indigenous Data Governance\n\n\n\n\n\n\n\n\n\nCARE\nDefinition\n\n\n\n\n(C) Collective Benefit\nData ecosystems shall be designed and function in ways that enable Indigenous Peoples to derive benefit from the data.\n\n\n(A) Authority to Control\nIndigenous Peoples’ rights and interests in Indigenous data must be recognized and their authority to control such data be empowered. Indigenous data governance enables Indigenous Peoples and governing bodies to determine how Indigenous Peoples, as well as Indigenous lands, territories, resources, knowledge and geographical indicators, are represented and identified within data.\n\n\n(R) Responsibility\nThose working with Indigenous data have a responsibility to share how those data are used to support Indigenous Peoples’ self-determination and collective benefit. Accountability requires meaningful and openly available evidence of these efforts and the benefits accruing to Indigenous Peoples.\n\n\n(E) Ethics\nIndigenous Peoples’ rights and well being should be the primary concern at all stages of the data life cycle and across the data ecosystem.\n\n\n\n\n\n16.1.4 CARE Principles in Practice\n\nMake your data access to Indigenous groups. Much of the CARE Principles are about sharing and making data accessible to Indigenous Peoples. To do so, consider publish your data on Indigenous founded data repositories such as:\n\nCollaborative Indigenous Research Digital Garden (CIRDG)\nMukurtu Wumpurrarni-kari Archive\n\nUse Traditional Knowledge (TK) and Biocultural (BC) Labels How do we think of intellectual property for Traditional and Biocultural Knowledge? Knowledge that outdates any intellectual property system. In many cases institution, organizations, outsiders hold the copy rights of this knowledge and data that comes from their lands, territories, waters and traditions. Traditional Knowledge and Biocultural Labels are digital tags that establish Indigenous cultural authority and governance over Indigenous data and collections by adding provenance information and contextual metadata (including community names), protocols, and permissions for access, use, and circulation. This way mark cultural authority so is recorded in a way that recognizes the inherent sovereignty that Indigenous communities have over knowledge. Giving Indigenous groups more control over their cultural material and guide users what an appropriate behavior looks like. A global initiative that support Indigenous communities with tools that attribute their cultural heritage is Local Contexts.\nAssess the CAREness of your research. Like FAIR, CARE Principles are a lens to apply to your work. With CARE, it’s important to center human well-being in addition to open science and data sharing. To do this, reflect on how you’re giving access to Indigenous groups, on who your data impacts and the relationships you have with them, and the ethical concerns in your work. The Arctic Data Center, a data repository for Arctic research, now requires an Ethical Research Practices Statement when submitting data to them. They also have multiple guidelines on how to write and what to include in an Ethical Research Practices Statement."
  },
  {
    "objectID": "session_16.html#thinking-with-care-lenses",
    "href": "session_16.html#thinking-with-care-lenses",
    "title": "16  FAIR and CARE principles",
    "section": "16.2 Thinking with CARE lenses",
    "text": "16.2 Thinking with CARE lenses\n\n\n\n\n\n\nCARE Exercise\n\n\n\nExplore the Arctic Data Center’s guidelines on writing an Ethical Research Practices Statement. Then write an Ethical Research Practices Statement for your current research. Switch statements with a partner and assess their statement."
  },
  {
    "objectID": "session_16.html#evaluating-fair",
    "href": "session_16.html#evaluating-fair",
    "title": "16  FAIR and CARE principles",
    "section": "16.3 Evaluating FAIR",
    "text": "16.3 Evaluating FAIR\n\n\n\n\n\n\nFAIR Exercise\n\n\n\nNow that we reviewed the FAIR principles in detail, go back to the EDI data package you looked into at the beginning of the week and carefully evaluate the FAIRness of the data package using our Data package assesment rubric, Evidence for FAIR and CARE.\n\nGroup A: SBC LTER: Reef: Abundance, size and fishing effort for California Spiny Lobster (Panulirus interruptus), ongoing since 2012\nGroup B: Physiological stress of American pika (Ochotona princeps) and associated habitat characteristics for Niwot Ridge, 2018 - 2019\nGroup C: Ecological and social interactions in urban parks: bird surveys in local parks in the central Arizona-Phoenix metropolitan area\nGroup D: Interagency Ecological Program: Fish catch and water quality data from the Sacramento River floodplain and tidal slough, collected by the Yolo Bypass Fish Monitoring Program, 1998-2021.\n\n\n\n\n\n\n\n\nCarroll, Stephanie Russo, Ibrahim Garba, Oscar L. Figueroa-Rodríguez, Jarita Holbrook, Raymond Lovett, Simeon Materechera, Mark Parsons, et al. 2020. “The CARE Principles for Indigenous Data Governance.” Data Science Journal 19 (1): 43. https://doi.org/10.5334/dsj-2020-043.\n\n\nCarroll, Stephanie Russo, Edit Herczog, Maui Hudson, Keith Russell, and Shelley Stall. 2021. “Operationalizing the CARE and FAIR Principles for Indigenous Data Futures.” Scientific Data 8 (1): 108. https://doi.org/10.1038/s41597-021-00892-0.\n\n\nWilkinson, Mark D., Michel Dumontier, IJsbrand Jan Aalbersberg, Gabrielle Appleton, Myles Axton, Arie Baak, Niklas Blomberg, et al. 2016. “The FAIR Guiding Principles for Scientific Data Management and Stewardship.” Scientific Data 3 (1): 160018. https://doi.org/10.1038/sdata.2016.18."
  },
  {
    "objectID": "session_17.html#learning-objectives",
    "href": "session_17.html#learning-objectives",
    "title": "17  Collaborating using Git & GitHub and Merge Conflicts",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nApply the principles, features, and collaboration tools of Git and GitHub to effectively collaborate with colleagues on code\nAnalyze and evaluate common causes of conflicts that arise when collaborating on repositories\nDemonstrate the ability to resolve conflicts using Git conflict resolution techniques\nApply workflows and best practices that minimize conflicts on collaborative repositories"
  },
  {
    "objectID": "session_17.html#introduction-to-git-and-github-tools-for-collaboration",
    "href": "session_17.html#introduction-to-git-and-github-tools-for-collaboration",
    "title": "17  Collaborating using Git & GitHub and Merge Conflicts",
    "section": "17.1 Introduction to Git and GitHub Tools for Collaboration",
    "text": "17.1 Introduction to Git and GitHub Tools for Collaboration\n\n\n\nArtwork by Allison Horst\n\n\nGit is not only a powerful tool for individual work but also an excellent choice for collaborating with friends and colleagues. Git ensures that after you’ve completed your contributions to a repository, you can confidently synchronize your changes with changes made by others.\nOne of the easiest and most effective ways to collaborate using Git is by utilizing a shared repository on a hosting service like GitHub. This shared repository acts as a central hub, enabling collaborators to effortlessly exchange and merge their changes. With Git and a shared repository, you can collaborate seamlessly and work confidently, knowing that your changes will be integrated smoothly with those of your collaborators.\n\n\n\nGraphic from Atlassian\n\n\nThere are many advanced techniques for synchronizing Git repositories, but let’s start with a simple example.\nIn this example, the Collaborator will clone a copy of the Owner’s repository from GitHub, and the Owner will grant them Collaborator status, enabling the Collaborator to directly pull and push from the Owner’s GitHub repository."
  },
  {
    "objectID": "session_17.html#collaborating-with-a-trusted-colleague-without-conflicts",
    "href": "session_17.html#collaborating-with-a-trusted-colleague-without-conflicts",
    "title": "17  Collaborating using Git & GitHub and Merge Conflicts",
    "section": "17.2 Collaborating with a trusted colleague without conflicts",
    "text": "17.2 Collaborating with a trusted colleague without conflicts\nWe start our collaboration by giving a trusted colleague access to our repository on GitHub. In this example, we define the Owner as the individual who owns the repository, and the Collaborator as the person whom the Owner chooses to give permission to make changes to their repository.\nThe Collaborator will make changes to the repository and then push those changes to the shared repository on GitHub. The Owner will then use pull to retrieve the changes without encountering any conflicts. This is the most ideal workflow.\nThe instructors will demonstrate this process in the next section.\n\nStep 0: Owner adds Collaborator to shared repository\nThe Owner must change the settings of the repository and give the Collaborator access to the repository by inviting them as a collaborator to the repository. Once the Collaborator has accepted the invite, they can contribute to the repository.\n\n\n\n\n\n\n\nStep 1: Collaborator clone\nTo be able to contribute to a repository, the Collaborator must clone the repository from the Owner’s GitHub account. To do this, the Collaborator should visit the GitHub page for the Owner’s repository, and then copy the clone URL. In R Studio, the Collaborator will create a new project from version control by pasting this clone URL into the appropriate dialog (see the earlier chapter introducing GitHub).\n\n\n\nStep 2: Collaborator edit\nWith a clone copied locally, the Collaborator can now make changes to the README.md file in the repository, adding a line or statement somewhere noticeable near the top. Save your changes.\n\n\nStep 3: Collaborator commit and push\nTo sync changes, the Collaborator will need to add, commit, and push their changes to the Owner’s repository. But before doing so, it’s good practice to pull immediately before committing to ensure you have the most recent changes from the Owner. So, in RStudio’s Git tab, first click the “Diff” button to open the Git window, and then press the green “Pull” down arrow button. This will fetch any recent changes from the origin repository and merge them. Next, add the changed README.Rmd file to be committed by clicking the check box next to it, type in a commit message, and click “Commit”. Once that finishes, then the Collaborator can immediately click “Push” to send the commits to the Owner’s GitHub repository.\n\n\n\n\n\n\n\nStep 4: Owner pull\nNow, the Owner can open their local working copy of the code in RStudio, and pull those changes down to their local copy.\nCongrats, the Owner now has your changes!\n\n\nStep 5: Owner edits, commit, and push\nNext, the Owner should do the same. Make changes to a file in the repository, save it, pull to make sure no new changes have been made while editing, and then add, commit, and push the Owner changes to GitHub.\n\n\nStep 6: Collaborator pull\nThe Collaborator can now pull down those Owner changes, and all copies are once again fully synced. And you’re off to collaborating."
  },
  {
    "objectID": "session_17.html#ex1-no-conflict",
    "href": "session_17.html#ex1-no-conflict",
    "title": "17  Collaborating using Git & GitHub and Merge Conflicts",
    "section": "17.3 Exercise 1: With a partner collaborate in a repository without a merge conflict",
    "text": "17.3 Exercise 1: With a partner collaborate in a repository without a merge conflict\n\n\n\n\n\n\nSetup\n\n\n\n\nGet into pairs, then choose one person as the Owner and one as the Collaborator\nBoth logon to GitHub\n\nThese next steps are for the Owner:\n\nNavigate to the {FIRSTNAME}_test repository\nGo to “Settings” and navigate to “Collaborators” in the “Access” section on the left-hand side\nUnder “Manage Access” click the button “Add people” and type the username of your Collaborator in the search box\nOnce you’ve found the correct username, click “Add {Collaborator username} to this repository\n\n\n\n\n\n\nNow, the Collaborator will follow this step:\n\nCheck your email for an invitation to GitHub or check your notifications (likely under “Your Organizations”) on GitHub to accept the invite to collaborate.\n\n\n\n\n\n\n\n\n\nLast thing, some Git configuration\n\n\n\nWhen Git released version 2.27, a new feature they incorporated allows users to specify how to pull, essentially, otherwise a warning will appear. To suppress this warning we need to configure our Git with this line of code:\ngit config pull.rebase false\npull.rebase false is a default strategy for pulling where it will try to auto-merge the files if possible, and if it can’t it will show a merge conflict\n\n\n\n\n\n\n\n\nInstructions\n\n\n\nYou will do the exercise twice, where each person will get to practice being both the Owner and the Collaborator roles.\n\nStep 0: Designate one person as the Owner and one as the Collaborator.\n\nRound One:\n\nStep 1: Owner adds Collaborator to {FIRSTNAME}_test repository (see Setup block above for detailed steps)\nStep 2: Collaborator clones the Owner’s {FIRSTNAME}_test repository\nStep 3: Collaborator edits the README file:\n\nCollaborator adds a new level 2 heading to README titled “Git Workflow”\n\nStep 4: Collaborator commits and pushes the README file with the new changes to GitHub\nStep 5: Owner pulls the changes that the Collaborator made\nStep 6: Owner edits the README file:\n\nUnder “Git Workflow”, Owner adds the steps of the Git workflow we’ve been practicing\n\nStep 7: Owner commits and pushes the README file with the new changes to GitHub\nStep 8: Collaborator pulls the Owners changes from GitHub\nStep 9: Go back to Step 0, switch roles, and then follow the steps in Round Two.\n\nRound Two:\n\nStep 1: Owner adds Collaborator to {FIRSTNAME}_test repository\nStep 2: Collaborator clones the Owner’s {FIRSTNAME}_test repository\nStep 3: Collaborator edits the README file:\n\nCollaborator adds a new level 2 heading to README titled “How to Create a Git Repository from an existing project” and adds the high level steps for this workflow\n\nStep 4: Collaborator commits and pushes the README file with the new changes to GitHub\nStep 5: Owner pulls the changes that the Collaborator made\nStep 6: Owner edits the README file:\n\nUnder “How to Create a Git Repository”, Owner adds the high level steps for this workflow\n\nStep 7: Owner commits and pushes the README file with the new changes to GitHub\nStep 8: Collaborator pulls the Owners changes from GitHub\n\nHint: If you don’t remember how to create a Git repository, refer to the chapter Intro to Git and GitHub where we created two Git repositories"
  },
  {
    "objectID": "session_17.html#a-note-on-advanced-collaboration-techniques",
    "href": "session_17.html#a-note-on-advanced-collaboration-techniques",
    "title": "17  Collaborating using Git & GitHub and Merge Conflicts",
    "section": "17.4 A Note on Advanced Collaboration Techniques",
    "text": "17.4 A Note on Advanced Collaboration Techniques\nThere are many Git and GitHub collaboration techniques, some more advanced than others. We won’t be covering advanced strategies in this course. But here is a table for your reference on a few popular Git collaboration workflow strategies and tools.\n\n\n\n\n\n\n\n\n\nCollaboration Technique\nBenefits\nWhen to Use\nWhen Not to Use\n\n\n\n\nBranch Management Strategies\n1. Enables parallel development and experimentation2. Facilitates isolation of features or bug fixes3. Provides flexibility and control over project workflows\nWhen working on larger projects with multiple features or bug fixes simultaneously.When you want to maintain a stable main branch while developing new features or resolving issues on separate branches.When collaborating with teammates on different aspects of a project and later integrating their changes.\nWhen working on small projects with a single developer or limited codebase.When the project scope is simple and doesn’t require extensive branch management.When there is no need to isolate features or bug fixes.\n\n\nCode Review Practices\n1. Enhances code quality and correctness through feedback2. Promotes knowledge sharing and learning within the team3. Helps identify bugs, improve performance, and ensure adherence to coding standards\nWhen collaborating on a codebase with team members to ensure code quality and maintain best practices.When you want to receive feedback and suggestions on your code to improve its readability, efficiency, or functionality.When working on critical or complex code that requires an extra layer of scrutiny before merging it into the main branch.\nWhen working on personal projects or small codebases with no collaboration involved.When time constraints or project size make it impractical to conduct code reviews.When the codebase is less critical or has low complexity.\n\n\nForking\n1. Enables independent experimentation and development2. Provides a way to contribute to a project without direct access3. Allows for creating separate, standalone copies of a repository\nWhen you want to contribute to a project without having direct write access to the original repository.When you want to work on an independent variation or extension of an existing project.When experimenting with changes or modifications to a project while keeping the original repository intact.\nWhen collaborating on a project with direct write access to the original repository.When the project does not allow external contributions or forking.When the project size or complexity doesn’t justify the need for independent variations.\n\n\nPull Requests\n1. Facilitates code review and discussion2. Allows for collaboration and feedback from team members3. Enables better organization and tracking of proposed changes\nWhen working on a shared repository with a team and wanting to contribute changes in a controlled and collaborative manner.When you want to propose changes to a project managed by others and seek review and approval before merging them into the main codebase.\nWhen working on personal projects or individual coding tasks without the need for collaboration.When immediate changes or fixes are required without review processes.When working on projects with a small team or single developer with direct write access to the repository.\n\n\n\nThe “When Not to Use” column provides insights into situations where it may be less appropriate to use each collaboration technique, helping you make informed decisions based on the specific context and requirements of your project.\nThese techniques provide different benefits and are used in various collaboration scenarios, depending on the project’s needs and team dynamics."
  },
  {
    "objectID": "session_17.html#merge-conflicts",
    "href": "session_17.html#merge-conflicts",
    "title": "17  Collaborating using Git & GitHub and Merge Conflicts",
    "section": "17.5 Merge conflicts",
    "text": "17.5 Merge conflicts\nMerge conflicts occur when both collaborators make conflicting changes to the same file. Resolving merge conflicts involves identifying the root of the problem and restoring the project to a normal state. Good communication, discussing file sections to work on, and avoiding overlaps can help prevent merge conflicts. However, if conflicts do arise, Git warns about potential issues and ensures that changes from different collaborators based on the same file version are not overwritten. To resolve conflicts, you need to explicitly specify whose changes should be used for each conflicting line in the file.\nIn this image, we see collaborators mbjones and metamattj have both made changes to the same line in the same README.md file. This is causing a merge conflict because Git doesn’t know whose changes came first. To resolve it, we need to tell Git whose changes to keep for that line, and whose changes to discard.\n\n\n17.5.1 Common ways to resolve a merge conflict\n1. Abort, abort, abort…\nSometimes you just made a mistake. When you get a merge conflict, the repository is placed in a “Merging” state until you resolve it. There’s a Terminal command to abort doing the merge altogether:\ngit merge --abort\nOf course, after doing that you still haven’t synced with your Collaborator’s changes, so things are still unresolved. But at least your repository is now usable on your local machine.\n2. Checkout\nThe simplest way to resolve a conflict, given that you know whose version of the file you want to keep, is to use the command line Git program to tell Git to use either your changes (the person doing the merge), or their changes (the Collaborator).\n\nkeep your Collaborator’s file: git checkout --theirs conflicted_file.Rmd\nkeep your own file: git checkout --ours conflicted_file.Rmd\n\nOnce you have run that command, then run add (staging), commit, pull, and push the changes as normal.\n3. Pull and edit the file\nBut that requires the command line. If you want to resolve from RStudio, or if you want to pick and choose some of your changes and some of your Collaborator’s, then instead you can manually edit and fix the file. When you pull the file with a conflict, Git notices that there is a conflict and modifies the file to show both your own changes and your Collaborator’s changes in the file. It also shows the file in the Git tab with an orange U icon, which indicates that the file is Unmerged, and therefore awaiting your help to resolve the conflict. It delimits these blocks with a series of less than and greater than signs, so they are easy to find:\n\n\n\n\n\nTo resolve the conflicts, simply find all of these blocks, and edit them so that the file looks how you want (either pick your lines, your Collaborator’s lines, some combination, or something altogether new), and save. Be sure you removed the delimiter lines that started with\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt;,\n=======,\nand &gt;&gt;&gt;&gt;&gt;&gt;&gt;.\n\nOnce you have made those changes, you simply add (staging), commit, and push the files to resolve the conflict."
  },
  {
    "objectID": "session_17.html#producing-and-resolving-merge-conflicts",
    "href": "session_17.html#producing-and-resolving-merge-conflicts",
    "title": "17  Collaborating using Git & GitHub and Merge Conflicts",
    "section": "17.6 Producing and resolving merge conflicts",
    "text": "17.6 Producing and resolving merge conflicts\nTo illustrate this process, the instructors are going to carefully create a merge conflict step by step, show how to resolve it, and show how to see the results of the successful merge after it is complete. First, the instructors will walk through the exercise to demonstrate the issues. Then, participants will pair up and try the exercise.\n\nStep 1: Owner and Collaborator ensure all changes are updated\nFirst, start the exercise by ensuring that both the Owner and Collaborator have all of the changes synced to their local copies of the Owner’s repository in RStudio. This includes doing a git pull to ensure that you have all changes local, and make sure that the Git tab in RStudio doesn’t show any changes needing to be committed.\n\n\nStep 2: Owner makes a change and commits\nFrom that clean slate, the Owner first modifies and commits a small change including their name on a specific line of the README.md file (we will change the first line, the title). Work to only change that one line, and add your username to the line in some form and commit the changes (but DO NOT push). We are now in a situation where the Owner has unpushed changes that the Collaborator can not yet see.\n\n\nStep 3: Collaborator makes a change and commits on the same line\nNow the Collaborator also makes changes to the same line (the first line, the title) on the README.md file in their RStudio copy of the project, adding their name to the line. They then commit. At this point, both the Owner and Collaborator have committed changes based on their shared version of the README.md file, but neither has tried to share their changes via GitHub.\n\n\nStep 4: Collaborator pushes the file to GitHub\nSharing starts when the Collaborator pushes their changes to the GitHub repo, which updates GitHub to their version of the file. The Owner is now one revision behind, but doesn’t know it yet.\n\n\nStep 5: Owner pushes their changes and gets an error\nAt this point, the Owner tries to push their change to the repository, which triggers an error from GitHub. While the error message is long, it basically tells you everything needed (that the Owner’s repository doesn’t reflect the changes on GitHub, and that they need to pull before they can push).\n\n\n\nStep 6: Owner pulls from GitHub to get Collaborator changes\nDoing what the message says, the Owner pulls the changes from GitHub, and gets another, different error message. In this case, it indicates that there is a merge conflict because of the conflicting lines.\n\nIn the Git pane of RStudio, the file is also flagged with an orange U, which stands for an unresolved merge conflict.\n\n\n\nStep 7: Owner edits the file to resolve the conflict\nTo resolve the conflict, the Owner now needs to edit the file. Again, as indicated above, Git has flagged the locations in the file where a conflict occurred with &lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======, and &gt;&gt;&gt;&gt;&gt;&gt;&gt;. The Owner should edit the file, merging whatever changes are appropriate until the conflicting lines read how they should, and eliminate all of the marker lines with &lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======, and &gt;&gt;&gt;&gt;&gt;&gt;&gt;.\n\nOf course, for scripts and programs, resolving the changes means more than just merging the text – whoever is doing the merging should make sure that the code runs properly and none of the logic of the program has been broken.\n\n\n\nStep 8: Owner commits the resolved changes\nFrom this point forward, things proceed as normal. The Owner first add the file changes to be made, which changes the orange U to a blue M for modified, and then commits the changes locally. The Owner now has a resolved version of the file on their system.\n\n\n\nStep 9: Owner pushes the resolved changes to GitHub\nHave the Owner push the changes, and it should replicate the changes to GitHub without error.\n\n\n\nStep 10: Collaborator pulls the resolved changes from GitHub\nFinally, the Collaborator can pull from GitHub to get the changes the Owner made.\n\n\nStep 11: Both can view commit history\nWhen either the Collaborator or the Owner view the history, the conflict, associated branch, and the merged changes are clearly visible in the history."
  },
  {
    "objectID": "session_17.html#exercise-2-with-a-partner-collaborate-in-a-repository-and-resolve-a-merge-conflict",
    "href": "session_17.html#exercise-2-with-a-partner-collaborate-in-a-repository-and-resolve-a-merge-conflict",
    "title": "17  Collaborating using Git & GitHub and Merge Conflicts",
    "section": "17.7 Exercise 2: With a partner collaborate in a repository and resolve a merge conflict",
    "text": "17.7 Exercise 2: With a partner collaborate in a repository and resolve a merge conflict\nNote you will only need to complete the Setup and Git configuration steps again if you are working in a new repository. Return to Exercise 1 for Setup and Git configuration steps.\n\n\n\n\n\n\nInstructions\n\n\n\nNow it’s your turn. In pairs, intentionally create a merge conflict, and then go through the steps needed to resolve the issues and continue developing with the merged files. See the sections above for help with each of the steps below. You will do the exercise twice, where each person will get to practice being both the Owner and the Collaborator roles.\n\nStep 0: Designate one person as the Owner and one as the Collaborator.\n\nRound One:\n\nStep 1: Both Owner and Collaborator pull to ensure both have the most up-to-date changes\nStep 2: Owner edits the README file and makes a change to the title and commits do not push\nStep 3: On the same line, Collaborator edits the README file and makes a change to the title and commits\nStep 4: Collaborator pushes the file to GitHub\nStep 5: Owner pushes their changes and gets an error\nStep 6: Owner pulls from GitHub to get Collaborator changes\nStep 7: Owner edits the README file to resolve the conflict\nStep 8: Owner commits the resolved changes\nStep 9: Owner pushes the resolved changes to GitHub\nStep 10: Collaborator pulls the resolved changes from GitHub\nStep 11: Both view commit history\nStep 12: Go back to Step 0, switch roles, and then follow the steps in Round Two.\n\nRound Two:\n\nStep 1: Both Owner and Collaborator pull to ensure both have the most up-to-date changes\nStep 2: Owner edits the README file and makes a change to line 2 and commits do not push\nStep 3: On the same line, Collaborator edits the README file and makes a change to line 2 and commits\nStep 4: Collaborator pushes the file to GitHub\nStep 5: Owner pushes their changes and gets an error\nStep 6: Owner pulls from GitHub to get Collaborator changes\nStep 7: Owner edits the README file to resolve the conflict\nStep 8: Owner commits the resolved changes\nStep 9: Owner pushes the resolved changes to GitHub\nStep 10: Collaborator pulls the resolved changes from GitHub\nStep 11: Both view commit history"
  },
  {
    "objectID": "session_17.html#best-practices-to-avoid-merge-conflicts",
    "href": "session_17.html#best-practices-to-avoid-merge-conflicts",
    "title": "17  Collaborating using Git & GitHub and Merge Conflicts",
    "section": "17.8 Best practices to avoid merge conflicts",
    "text": "17.8 Best practices to avoid merge conflicts\nSome basic rules of thumb can avoid the vast majority of merge conflicts, saving a lot of time and frustration. These are words our teams live by:\n\n\n\n\n\nXKCD 1597\n\n\n\nCommunicate often and set up effective communication channels\nTell each other what you are working on\nStart your working session with a pull\nPull immediately before you commit or push\nCommit often in small chunks (this helps you organize your work!)\nMake sure you and who you are collaborating with all fully understand the Git workflow you’re using aka make sure you’re on the same page before you start!\n\nA good workflow is encapsulated as follows:\nPull -&gt; Edit -&gt; Save -&gt; Add (stage) -&gt; Commit -&gt; Pull -&gt; Push\nAlways start your working sessions with a pull to get any outstanding changes, then start your work. Stage your changes, but before you commit, pull again to see if any new changes have arrived. If so, they should merge in easily if you are working in different parts of the program. You can then commit and immediately push your changes safely.\nGood luck, and try to not get frustrated. Once you figure out how to handle merge conflicts, they can be avoided or dispatched when they occur, but it does take a bit of practice."
  },
  {
    "objectID": "session_19.html#learning-objectives",
    "href": "session_19.html#learning-objectives",
    "title": "19  Reproducibility & Provenance",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nIn this lesson, we will:\n\nDiscuss the concept of reproducible workflows including computational reproducibility and provenance metadata\nLearn how to use R to package your work by building a reproducible paper in RMarkdown\nIntroduce tools and techniques for reproducibility supported by the NCEAS and DataONE\n\n\n19.0.1 Reproducible Research: Recap\nWorking in a reproducible manner:\n\nIncreases research efficiency, accelerating the pace of your research and collaborations.\nProvides transparency by capturing and communicating scientific workflows.\nEnables research to stand on the shoulders of giants (build on work that came before).\nAllows credit for secondary usage and supports easy attribution.\nIncreases trust in science.\n\nTo enable others to fully interpret, reproduce or build upon our research, we need to provide more comprehensive information than is typically included in a figure or publication. The methods sections of papers are typically inadequate to fully reproduce the work described in the paper.\n\nFor example, if we look at the figure above convey multiple messages. But, by looking at the figure we don’t get the full story how did scientist got to make this plot. What data were used in this study? What methods applied? What were the parameter settings? What documentation or code are available to us to evaluate the results? Can we trust these data and methods? Are the results reproducible?\nComputational reproducibility is the ability to document data, analyses, and models sufficiently for other researchers to be able to understand and ideally re-execute the computations that led to scientific results and conclusions.\nPractically speaking, reproducibility includes:\n\nPreserving the data\nPreserving the software workflow\nDocumenting what you did\nDescribing how to interpret it all\n\nA recent study of publicly-available datasets in the Harvard Database repository containing R files found that only 26% of R files ran without error in the initial execution. 44% were able to be run after code cleaning, showing the importance of good programming practice (Trisovic et al. 2022). The figure below from Trisovic et al. shows a sankey diagram of how code cleaning was able to fix common errors.\n\n\n\n19.0.2 Computational Provenance and Workflows\nComputational provenance refers to the origin and processing history of data including:\n\nInput data\nWorkflow/scripts\nOutput data\nFigures\nMethods, dataflow, and dependencies\n\nWhen we put these all together with formal documentation, we create a computational workflow that captures all of the steps from initial data cleaning and integration, through analysis, modeling, and visualization. In other words, computational provenance is a formalized description of a workflow from the origin of the data to it’s final outcome.\nHere’s an example of a computational workflow from Mark Carls: Mark Carls. Analysis of hydrocarbons following the Exxon Valdez oil spill, Gulf of Alaska, 1989 - 2014. Gulf of Alaska Data Portal. urn:uuid:3249ada0-afe3-4dd6-875e-0f7928a4c171., that represents a three step workflow comprising four source data files and two output visualizations.\n\n\nThis image is a screenshot of an interactive user interface of a workflow built by DataONE. You can clearly see which data files were inputs to the process, the scripts that are used to process and visualize the data, and the final output objects that are produced, in this case two graphical maps of Prince William Sound in Alaska.\n\n\n19.0.3 From Provenance to Reproducibility\n\nDataONE provides a tool to track and visualize provenance. It facilitates reproducible science through provenance by:\n\nTracking data derivation history\nTracking data inputs and outputs of analyses\nPreserving and documenting software workflows\nTracking analysis and model executions\nLinking all of these to publications\n\n\nOne way to illustrate this is to look into the structure of a data package. A data package is the unit of publication of your data, including datasets, metadata, software and provenance. The image below represents a data package and all it’s components and how these components relate to each other.\n\n\n\n\n19.0.4 Data Citation and Transitive Credit\nWe want to move towards a model such that when a user cites a research publication we will also know:\n\nWhich data produced it\nWhat software produced it\nWhat was derived from it\nWho to credit down the attribution stack\n\n\nThis is transitive credit. And it changes the way in which we think about science communication and traditional publications.\n\n\n19.0.5 Reproducible Papers with rrtools\nA great overview of this approach to reproducible papers comes from:\n\nBen Marwick, Carl Boettiger & Lincoln Mullen (2018) Packaging Data Analytical Work Reproducibly Using R (and Friends), The American Statistician, 72:1, 80-88, doi:10.1080/00031305.2017.1375986\n\nThe key idea in Marwick et al. (2018) is that of the research compendium: A single container for not just the journal article associated with your research but also the underlying analysis, data, and even the required software environment required to reproduce your work.\nResearch compendium makes it easy for researchers to do their work but also for others to inspect or even reproduce the work because all necessary materials are readily at hand due to being kept in one place. Rather than a constrained set of rules, the research compendium is a scaffold upon which to conduct reproducible research using open science tools such as:\n\nR\nRMarkdown\ngit and GitHub\n\nFortunately for us, Ben Marwick (and others) have written an R package called rrtools that helps us create a research compendium from scratch.\n\n\n\n\n\n\nSet up\n\n\n\nTo start a reproducible paper with rrtools:\n\nClose your username-training project. Go to the project switcher dropdown, just click “close project.” This will set your working directory back to your home directory.\nIn console run the following line of code\n\n\n## \"mypaper\" is the name of the Rproj with my research compendia\nrrtools::use_compendium(\"mypaper\")\n\nrrtools has created the beginnings of a research compendium for us. The structure of this compendium is similar to the one needed to built an R package. That’s because it uses the same underlying folder structure and metadata and therefore it technically is an R package (called mypaper). And this means our research compendium could be easy to install in someone elses’ computer, similar to an R package.\n\nrrtools also helps you set up some key information like:\n\n\nSet up a README file in the RMarkdown format\nCreate an analysis folder to hold our reproducible paper\n\n\nrrtools::use_readme_rmd()\nrrtools::use_analysis()\n\nThis creates a standard, predictable layout for our code and data and outputs that multiple people can understand. At this point, we’re technically ready to start writing the paper. But.. What about GitHub?\n\n\n\n19.0.5.1 Creating a git and GitHub repository with usethis\n\nusethis is a package that facilitates interactive workflows for R project creation and development. It automates repetitive tasks that arise during project setup and development.\n\nWe are going to use two functions to start tracking our work in git, create a remote repository in GitHub and be able to push and pull between the local version and the remote. To learn more about this package checkout the package documentation.\n\n\n\n\n\n\nSet up\n\n\n\n\nMake sure your are in “mypaper” Rproj.\nIn the Console run usethis::use_git() to create a local git repo. Choose yes to both questions when prompted (to commit files, and to restart R).\nThen, in the Console, run usethis::use_github() to create an upstream remote repo (in GitHub).\n\nAnd that’s it! Now your have your research compendium in your local computer and your changes are being tracked by git and your can pull and push to GitHub.\n\n\nLet’s explore the structure rrtools has put in place for us. Inside the analysis folder we have 5 folders. Different parts of our project will go into this different folders. Our data into the data folder, when the time comes to save any figure, we should save them into the figures folder, and so on.\n\n\n\nResearch compendia from Marwick et al.\n\n\nYou’ll notice a analysis/templates directory that contains journal citation style language (CSL) files which set the style of citations and reference list for the journal (the Journal of Archaeological Science, in this example). The template.Rmd renders into the template.docx. This document is called in the paper.qmd YAML to style the output of the paper created in paper.qmd.\nWhat if I want a template from another journal, different from the Journal of Archeological Science? We can create other journal’s template with the rticles package. This package will provide the templates and necessary information to render your paper in the journal of your choice (note: not all journal are in the rticles package). With that in mind, we will delete the existing paper directory and create a new one shortly.\n\n\n\n19.0.6 RMarkdown templates with rticles\nThe rticles package provides a lot of other great templates for formatting your paper specifically to the requirements of many journals. In addition to a custom CSL file for reference customization, rticles supports custom LATeX templates that fit the formatting requirements of each journals.\n\n\n\n\n\n\nSet up\n\n\n\n\nIf you do not have rticle installed, go aherad and inatall calling the following function in the console: install.packages('rticles') Restart your RStudio session\nTo create a new file from rticlescustom templates, got to File | New File | R Markdown... menu, which shows the following dialog:\n\n\n\nGo to “From Template” in the left side menu.\nSelect the “PNAS” template, give the file a name and set the location of the files to be mypaper/analysis, and click “OK”.\nYou can now Knit the Rmd file to see a highly-targeted article format, like this one for PNAS:\n\n\n\n\n\n\n19.0.7 Workflow in a nutshell\n\n\n\n\n\n\nSummary\n\n\n\n\nUse rrtools to generate the core directory layout and approach to data handling.\nThen use rticles to create the structure of the paper itself. The combination is incredibly flexible.\n\n\n\nThings we can do with our research compendium:\n\nEdit ./analysis/paper/paper.Rmd to begin writing your paper and your analysis in the same document\nAdd any citations to ./analysis/paper/pnas-sample.bib\nAdd any longer R scripts that don’t fit in your paper in an R folder at the top level\nAdd raw data to ./data/raw_data\nWrite out any derived data (generated in paper.Rmd) to ./data/derived_data\nWrite out any figures in ./analysis/figures\n\nYou can then write all of your R code in your RMarkdown, and generate your manuscript all in the format needed for your journal (using it’s .csl file, stored in the paper directory).\n\n\n19.0.8 Adding renv to conserve your environment\n\nrrtools has a couple more tricks up it’s sleeve to help your compendium be as reproducible and portable as possible.\nTo capture the R packages and versions this project depends on, we can use the renv package.\nRunning renv::init(), will initiate tracking of the R packages in your project.\nThis action will create a new folder called renv in your top directory.\nrenv::init() automatically detects dependencies in your code (by looking for library calls, at the DESCRIPTION file, etc.) and installs them to a private project specific library. This means that your project mypaper can use a different version of dplyr than another project which may need an older version without any hassle.\nrenv also write the package dependencies to a special file in the repository called renv.lock.\nIf any of your packages you are using is updated, while your are working on your project, you can run renv::snapshot() to update the renv.lock file and your project-installed packages.\nYou can read the renv.lock file using renv::restore(), when needed. This will install the versions of the packages needed.\n\n\n\n19.0.9 Conserve your computational environement with Docker\n\nThe rrtools package then uses this renv.lock file to build what is called a Dockerfile.\nDocker allows you to build containers, a standard unit of software that packages up code and all its dependencies so an application runs quickly and reliably from one computing environment to another.\nA container is an “image” of all the software specified, and this image can be run on other computers such that the software stack looks exactly as you specify.\nThis is important when it comes to reproducibility, because when running someone else code, you may get different results or errors if you are using different versions of software (like an old version of dplyr).\nA Dockerfile contains the instructions for how to recreate the computational environment where your analysis was run.\n\nIn practice\n\nOnce you have your research compendium, you can called rrtools::use_dockerfile()\nThis, first creates a Dockerfile that loads a standard image for using R with the tidyverse,\nAnd then has more instructions for how to create the environment so that it has the very specific R packages and versions you need.\nIf we look at the Dockerfile (example below), it calls to renv::restore(), as described above.\nThe last line of the docker file renders our RMarkdown reproducible paper!\n\n# get the base image, the rocker/verse has R, RStudio and pandoc\nFROM rocker/verse:4.1.0\n\n# required\nMAINTAINER Jeanette Clark &lt;jclark@nceas.ucsb.edu&gt;\n\nCOPY . /mypaper\n\n# go into the repo directory\nRUN . /etc/environment \\\n  # Install linux depedendencies here\n  # e.g. need this for ggforce::geom_sina\n  && sudo apt-get update \\\n  && sudo apt-get install libudunits2-dev -y \\\n  # build this compendium package\n  && R -e \"install.packages('remotes', repos = c(CRAN = 'https://cloud.r-project.org'))\" \\\n  && R -e \"install.packages(c('renv', 'rmarkdown'))\" \\\n  # install pkgs we need\n  && R -e \"renv::restore()\" \\\n  # render the manuscript into a pdf,\n  && R -e \"rmarkdown::render('mypaper/analysis/paper/paper.Rmd')\"\n\nAfter running rrtools::use_dockerfile(), the package also sets up GitHub Actions for you.\nActions are processes that are triggered in GitHub events (like a push) and run automatically.\nIn this case, the Action that is set up will build your Docker image on GitHub.\nThis means that the code that knits your paper is run, and an updated version of your paper is knit.\nThis is called continuous integration, and is extremely convenient for developing products like this, since the build step can be taken care of automatically as you push to your repository.\n\n\n\n\n19.0.10 The 5th Generation of Reproducible Papers\n\nWhole Tale is a project that aims to simplify computational reproducibility. It enables researchers to easily package and share ‘tales’. Tales are executable research objects captured in a standards-based tale format complete with metadata. They can contain:\n\nData (references)\nCode (computational methods)\nNarrative (traditional science story)\nCompute environment (e.g. RStudio, Jupyter)\n\n\nBy combining data, code and the compute environment, tales allow researchers to:\n\nRe-create the computational results from a scientific study\nAchieve computational reproducibility\n“Set the default to reproducible.”\n\nThey also empower users to verify and extend results with different data, methods, and environments. You can browse existing tales, run and interact with published tales and create new tales via the Whole Tale Dashboard.\n\nBy integrating with DataONE and Dataverse, Whole Tale includes over 90 major research repositories from which a user can select datasets to make those datasets the starting point of an interactive data exploration and analysis inside of one of the Whole Tale environments. DataONE, is adding functionality to work with data in the Whole Tale environment directly from the dataset landing page.\nFull circle reproducibility can be achieved by publishing data, code AND the environment.\n\n\n19.0.11 Resources\n\nrrtools documentation\nThe rticles\nusethis documentation\n\n\n\n\n\nTrisovic, Ana, Matthew K. Lau, Thomas Pasquier, and Mercè Crosas. 2022. “A Large-Scale Study on Research Code Quality and Execution.” Scientific Data 9 (1). https://doi.org/10.1038/s41597-022-01143-6."
  }
]